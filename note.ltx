\documentclass[a4paper,10pt]{article}

\usepackage{color}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}

%% Encoding, font stuff
%\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

\usepackage{bbm}
\usepackage{bbding}

%% Symbols and whatever
\usepackage{amsmath,amsthm,amssymb,amsfonts,stmaryrd}

%include note.fmt

%% Layout stuff and other related goodies.
\usepackage[parfill]{parskip}
\usepackage{xspace}
\usepackage{todonotes}

%% URLs and other link stuff
\usepackage{url}
\usepackage{hyperref}
\usepackage[noabbrev]{cleveref}

\hypersetup{
  colorlinks,
  citecolor=DarkBlue,
  linkcolor=black,
  urlcolor=DarkBlue}

% Bibliography stuff
\usepackage[autostyle]{csquotes}

\usepackage[
    backend=biber,
    bibstyle=numeric, 
    citestyle=authoryear,
    natbib=true,
    hyperref=true,
    url=false, 
    doi=true,
    eprint=false
]{biblatex}
\addbibresource{refs.bib}

\input{fixbib.tex}

%% Tikz setup
\usepackage{tikz}
\usetikzlibrary{decorations.pathmorphing} % for snake lines
\usetikzlibrary{matrix}


%% Commands
\newcommand{\todoi}[1]{\todo[inline]{#1}}
\newcommand{\withoutk}{\xspace\verb+--without-K+\xspace}
\newcommand{\uip}{uniqueness of identity proofs\xspace}
\newcommand{\Uip}{Uniqueness of identity proofs\xspace}
\newcommand{\hott}{homotopy type theory\xspace}
\newcommand{\Hott}{Homotopy type theory\xspace}
\newcommand{\mltt}{Martin-L\"of's type theory\xspace}
\newcommand{\hit}{higher inductive type\xspace}
\newcommand{\Hit}{Higher inductive type\xspace}
\newcommand{\hits}{higher inductive types\xspace}
\newcommand{\Hits}{Higher inductive types\xspace}
\newcommand{\oit}{ordinary inductive type\xspace}
\newcommand{\Oit}{Ordinary inductive type\xspace}
\newcommand{\oits}{ordinary inductive types\xspace}
\newcommand{\Oits}{Ordinary inductive types\xspace}
\newcommand{\zeroconstructor}{$0$-constructor\xspace}
\newcommand{\zeroconstructors}{$0$-constructors\xspace}
\newcommand{\onehit}{$1$-HIT\xspace}
\newcommand{\onehits}{$1$-HITs\xspace}
\newcommand{\oneconstructor}{$1$-constructor\xspace}
\newcommand{\oneconstructors}{$1$-constructors\xspace}
\newcommand{\twohit}{$2$-HIT\xspace}
\newcommand{\twohits}{$2$-HITs\xspace}
\newcommand{\twoconstructor}{$2$-constructor\xspace}
\newcommand{\twoconstructors}{$2$-constructors\xspace}
\newcommand{\zerovariable}{$0$-variable\xspace}
\newcommand{\onevariable}{$1$-variable\xspace}
\newcommand{\twovariable}{$2$-variable\xspace}
\newcommand{\zerovariables}{$0$-variables\xspace}
\newcommand{\onevariables}{$1$-variables\xspace}
\newcommand{\twovariables}{$2$-variables\xspace}
\newcommand{\nhit}[1]{$#1$-HIT\xspace}
\newcommand{\nhits}[1]{$#1$-HITs\xspace}
\newcommand{\ie}{i.e.\xspace}
\newcommand{\eg}{e.g.\xspace}
\newcommand{\Type}{\mbox{Type}}
\newcommand{\wtypes}{$W$-types\xspace}
\newcommand{\wtype}{$W$-type\xspace}
\newcommand{\ronehit}{restricted \onehit}
\newcommand{\ronehits}{restricted \onehits}
\newcommand{\Ronehit}{Restricted \onehit}
\newcommand{\Ronehits}{Restricted \onehits}

\title{Second year report}

\author{Gabe Dijkstra}

\date{}

\begin{document}

\maketitle

\section{Introduction}

\section{Describing \hits}

If we define an ordinary inductive type, we start out by writing down
a list of constructors, \eg:

\begin{code}
  data T : Type where
    c0  : F0 T -> T
    c1  : F1 T -> T
        vdots
    ck  : Fk T -> T
\end{code}

where all |Fi : Type -> Type| are strictly positive
functors. Equivalently, we can define an inductive type with a single
constructor:

\begin{code}
  data T : Type where
    c : F T -> T
\end{code}

where |F X := F0 X + F1 X + hdots + Fk X|, so a single strictly
positive functor is all we need to describe an \oit.

In the case of \hits, the situation is more involved. Consider for
example the circle data type:

\begin{code}
  data S1 : Type where
    base : S1
    loop : base == base
\end{code}

There are two things that are different from our previous
situation. Firstly, the result type of |loop| is not |S1|, but a path
space of |S1|: constructors are no longer algebras of functor, but a
kind of \emph{dialgebra}: the arguments as well as the result type of
a constructor may vary. Secondly, the |loop| constructor refers to the
previous constructor |base|.

The result type of a constructor can also depend on the value of its
arguments, as we see in the definition of propositional truncation as
a \hit:

\begin{code}
  data // A // : Type where
    [_] : A -> // A //
    trunc : (x y : // A //) -> x == y
\end{code}

Constructors of a \hit are \emph{dependent dialgebras}. In general, a
higher inductive type looks as follows:

\begin{code}
  data T : Type where
    c0    : (x : F0 T)              -> G0 T x
    c1    : (x : F1 T c0)           -> G1 T c0 x
    c2    : (x : F2 T c0 c1)        -> G2 T c0 c1 x
          vdots
    ckp1  : (x : Fk T c0 hdots ck)  -> Gk T c0 hdots ck x
\end{code}

We will refer to the |Fi| functors as \emph{argument} functors and the
|Gi| functors as \emph{target} functors. The types of the argument
functors are:

\begin{code}
F0   : Type          -> Type
F1   : (F0, G0)-alg  -> Type       
F2   : (F1, G1)-alg  -> Type       
Fkp1 : (Fk, Gk)-alg  -> Type
\end{code}

where |(F0, G0)-alg)| is the category whose objects are dependent
dialgebras |(X : Type) × (θ : (x : F0 X) -> G0 X x)|. The category
|(Fip1,Gip1)-alg| has as objects: |(X : (Fi, Gi)-alg) × (θ : (x :
Fip1 X) -> Gip1 X x)|. The target functors also take the value of
the arguments as an argument, so they have the following types:

\begin{code}
G0    : int Type          F0    -> Type
G1    : int (F0, G0)-alg  F1    -> Type       
G2    : int (F1, G1)-alg  F2    -> Type       
Gkp1  : int (Fk, Gk)-alg  Fkp1  -> Type
\end{code}

We see that the general shape of a constructor is a dependent dialgebra:

\begin{code}
  c : (x : F X) -> G (X , x)
\end{code}

where |catC : Cat|, |F : catC -> Type| and |G : int catC F -> Type|,
where |catC| is |Type| or some category of dependent dialgebras,
``containing'' all the previous constructors.

When describing \hits, we do not allow for any target functor |G|: it
must either return the type we are defining or a (possibly iterated)
path space of that type. A constructor of which the target is an
$n$-times iterated path space is called an \emph{$n$-constructor}. The
$0$-times iterated path space of a type |A| is simply the type |A|
itself, hence ordinary constructors are \zeroconstructors. We call a
\hit an $n$-\hit if $n$ is the maximum iteration depth of its
constructors.

A \emph{\zeroconstructor} or \emph{point constructor} is a dialgebra:

\begin{code}
  c : (x : F X) -> U X
\end{code}

where |catC : Cat|, |F : catC -> Type| and |U : catC -> Type| its forgetful
functor.

A \emph{\oneconstructor} is a dependent dialgebra of which the target
functor returns a path space:

\begin{code}
  c : (x : F X) -> Eq0 X x
\end{code}

where |catC : Cat|, |F, U : catC -> Type|, and |Eq0 : int catC F ->
Type| is the functor:

\begin{code}
  Eq0 (X , x) := (l0 X x == r0 X x)
\end{code}

where |l0, r0 : F -> U| are natural transformations.

For higher path constructors, we have to specify a tower of natural
transformations, specifying the end points at every level. To specify
an |(k+1)|-constructor, we need to give the natural transformations:

\begin{code}
  l0, r0  : F -> U
  l1, r1  : 1 -> Eq0
  l2, r2  : 1 -> Eq1
          vdots
  lk, rk  : 1 -> Eqkm1
\end{code}

where |Eqi X x := (li X x == ri X x)|. |Eqn| is then the target
functor we are interested in.

\subsection{$0$-\hits versus \oits}

Even when we consider only \oneconstructors, the above scheme is more
general than the schemes that are usually considered when talking
about \oits: any constructor may refer to any previous
constructor, \eg:

\begin{code}
  data T : Type where
    c0 : T
    c1 : c0 == c0 -> T
\end{code}

In fact, Agda even allows such definitions.

One variation of inductive types where one can refer to previous
constructors are \emph{inductive-inductive} types. An
inductive-inductive type is an inductive type |A| along with an
inductive family |B : A -> Type|, where the constructors of |A| may
refer to |B| and where |B| may refer to |A| and its constructors.

An example of an inductive-inductive definition is that of types and
contexts:

\begin{code}
  data Ctx : Type where
    ε   : Ctx
    _·_ : Ctx -> Ty -> Ctx

  data Ty : Ctx -> Type where
    zero  : (Γ : Ctx) -> Ty Γ
    one   : (Γ : Ctx) -> Ty Γ
    pi    : (Γ : Ctx) -> (x : Ty Γ) -> Ty (Γ · x) -> Ty Γ
\end{code}

We can generalise our scheme of \hits to also support mutual
definitions, such as the above. Instead of considering target functors
mapping into |Type|, it can be an arbitrary base category. This
construction is described in \textcite{Capriotti2014ii}.

\emph{Higher} inductive-inductive types also turn out to be useful
when formalising type theory in type
theory \parencite{Altenkirch2015}.

\subsection{Strict positivity}

Apart from the restrictions on targets, we also want all functors
involved to be strictly positive. In the case of \oits, we also have
this restriction. An example of an inductive type which constructor is
not strictly positive is the following:

\begin{code}
  data Term : Type where
    lam : (Term -> Term) -> Term
\end{code}

Using the type |Term|, we can find inhabitants of the empty type. We
therefore only consider inductive types defined by strictly positive
functors, \ie containers \parencite{Abbott2005}. Containers however
only describe functors |Type -> Type|. An example of that shows that
we need a notion of strict positivity for any functor into |Type| is
that of the ``initial field''. If we write down the axioms of an
algebraic structure as constructors, the inductive type we get is then
the initial object in the category of that algebraic structure, \ie we
can define a type |T| with the monoid axioms as constructors:

\begin{code}
  data T : Type where
    uip : (x y : T) (p q : x == y) -> p == q
    _∙_ : T -> T -> T
    assoc : (x y z : T) -> (x ∙ y) ∙ z == x ∙ (y ∙ z)
    e : T
    e-unit-l : (x : T) -> e ∙ x == x
    e-unit-r : (x : T) -> x ∙ e == x
\end{code}

|T| is equivalent to the unit type, which is the initial object in the
category of monoids. If we now were to write down the axioms of a
field, we run into trouble: there is no initial object in the category
of fields. The culprit is the inverse operation, which has the type:

\begin{code}
  inv : (x : T) -> (x == 0 -> ⊥) -> T
\end{code}

The constructor |0| occurs negatively in this constructor.

\subsubsection{Generalised containers}

To generalise the notion of strict positivity, we can generalise the
notion of containers to not only describe functors |Type -> Type|, but
functors \emph{into} |Type| from any |catC : Cat|. A \emph{generalised
  container} is given by:

\begin{code}
  S : Type
  P : S -> / catC /
\end{code}

Its extension is then defined as:

\begin{code}
  ⟦ S ◁ P ⟧ : catC -> Type
  ⟦ S ◁ P ⟧ X := (s : S) × catC(P s, X)
\end{code}

with the action on morphisms defined as:

\begin{code}
  ⟦ S ◁ P ⟧ : catC(X , Y) -> ⟦ S ◁ P ⟧ X -> ⟦ S ◁ P ⟧ Y
  ⟦ S ◁ P ⟧ f (s , t) := (s , f ∘ t)
\end{code}

Just as with ordinary containers, we can define container morphisms
for generalised containers in the standard way: for containers |S ◁ P|
and |T ◁ Q|, a container morphism |S ◁ P -> T ◁ Q| is comprised of:

\begin{code}
  f : S -> T
  g : (a : S) -> catC(Q (f a) , P a)
\end{code}

with its action of objects defined as:

\begin{code}
  ⟦ (f , g) ⟧ : (X : / catC /) -> ⟦ S ◁ P ⟧ X -> ⟦ T ◁ Q ⟧ X
  ⟦ (f , g) ⟧ X (s , t) := (f s , t ∘ (g s))
\end{code}

Equivalently, container morphisms |S ◁ P -> T ◁ Q| are sections of the
form:

\begin{code}
  (s : S) -> ⟦ T ◁ Q ⟧ (P s)
\end{code}

Generalised containers are essentially the same as \emph{familially
  representable functors} \parencite{Carboni1995}.

\subsection{Coherence issues}

Even though the above definition of strictly positive functors |catC
-> Type| looks as something that is easily formalisable, we have not
explained how to formalise the notion of category. 

mention typical situation where we have a type of objects and a set of
morphisms (precategory). If we also have that isomorphism in category
coincides with equality of objects, then this is called a
category. (AKS) In such a category the type of objects is a $1$-type,
so this is unsuitable for our purposes.

Instead of talking about ordinary category, we want to talk about
$(\infty, 1)$-categories. As of yet, no one has found a practical way
to formalise these in type theory, so this is not a viable option for
us right now.

Another way to talk about categories, is to have a type of objects and
a type of morphisms, with the requirement that all category laws hold
strictly. |Type| is an example of such a strict category:
associativity and the identity laws hold definitionally. This approach
gets us into trouble if we define the category of algebras, as the
definition of algebra morphism refers to propositional equality and
associativity no longer holds definitionally. One way to solve this
problem is to extend the type theory we are working in to also have a
``strict equality'', as is done in HTS.

In this report we will take yet another approach: we will define
categories with a type of objects and a type of morphisms and require
the category laws to hold by propositional equality, but without
imposing any extra coherence laws on them. This corresponds to the
concept of a \emph{H-category}. Additionally, we will restrict
ourselves to such \hit definitions that minimise the amount of
coherence issues we have to deal with. Since we are working with a
limited set of categories that we have explicitly defined, we can deal
with any coherence issues as they come up.

\subsection{\Hits as a sequence of monads}

Given a strictly positive functor |F : Type -> Type|, we can consider
its category of algebras |F-alg|. |F-alg| has a forgetful functor |U :
F-alg -> Type|, which has a left adjoint |L : Type -> F-alg| that maps
a type to its free |F|-algebra. Note that plugging in the initial
object in |Type|, \ie the empty type into |L| gives us the initial
object in |F-alg|, as left adjoints preserve colimits. The monad |UL|
is called the \emph{free monad} of |F|, also denoted as |F *|. This
monad has the property that the category of |F|-algebras is equivalent
to the category of monad algebras of |F *|. \Hits can be contrasted to
\oits as being characterised by a more general class of monads than
just free monads.

\section{\Ronehits}

Instead of considering a \hit with arbitrarily many constructors, we
can restrict ourselves to having two constructors: a \zeroconstructor
followed by a \oneconstructor. The data we need to supply for this is:

\begin{code}
  F0 : Type -> Type
  F1 : F0-alg -> Type
\end{code}

with the target of the \oneconstructor given by:

\begin{code}
  G : int (F0-alg) F1 -> Type
  G X θ x := (l X θ x == r X θ x)
\end{code}

for natural transformations |l, r : F1 -> U| where |U : F0-alg ->
Type| the forgetful functor. If |F1| factors through |U|, \ie the
arguments of the \oneconstructor do not refer to the \zeroconstructor,
then can simplify the situation even further. Suppose |F1 == F1' ∘ U|
for some |F1' : Type -> Type|, natural transformations |F1 -> U| can
be given by natural transformations |F1' -> F0 *|, where |F0 *| is the
free monad of |F0|. Recall that |U| has a left adjoint |L| such that
|F0 * == UL|. Since |U| has a left adjoint, it is representable, for
any |X : Type|:

\begin{code}
  U X  == 1 -> U X
       == F0-alg(L1 , U X)
\end{code}

If |F1' = S ◁ P|, then we can characterise natural transformations |F1
-> U| as container morphisms. We can calculate the container
representation of the composition |F1' ∘ U| as follows: suppose |X :
Type|, then:

\begin{code}
  F1' (U X)  == F1' (F0-alg(L1 , X))
             == (s : S) × (P s -> F0-alg(L1 , X))
             == (s : S) × (P s -> 1 -> U X)
             == (s : S) × (P s -> U X)
             == (s : S) × (F0-alg(L (P s) , X))
\end{code}

So the container representation of |F1' ∘ U| is |S ◁ L ∘ P|. Using
this we can derive the following:

\begin{code}
  F1 -> U
   == { definition of F1 }
  F1' ∘ U -> U
   == { container morphisms }
  (s : S) -> U (L (P s))
   == { definition of F * }
  (s : S) -> F0 * (P s)
   == { container morphisms }
  F1' -> F0 *
\end{code}

The data we need to describe a \ronehit consists of:

\begin{code}
  F0 : Type -> Type
  F1 : Type -> Type
  l, r : F1 -> F0 *
\end{code}

where |F0, F1| are given as container and |l, r| as container
morphisms. Given these data, the \ronehit then looks as follows:

\begin{code}
  data T : Type where
    c0 : F0 T -> T
    c1 : (x : F1 T) -> c0 * (l x) == c0 * (r x)
\end{code}

where |c0 * : F0 * T -> T| is the lifting of the |F0|-algebra |c0 : F0
T -> T| to a (monad) |F0 *|-algebra.

The advantage of restricting ourselves to the above situation is that
we can give the description of a \hit using only ordinary containers
and container morphisms. This avoids dealing with the coherence
problems that stem from defining categories of algebras, needed to
give the generalised containers for the constructors.

Many \hits we see ``in the wild'' can be captured by this approach,
such as the circle and |n|-truncation.

One limitation however is that it does not handle ``nested'' \hits
directly. The following example is not expressible, as the functor |//
_ // : Type -> Type| is not a container:

\begin{code}
  data T : Type where
    c : // T // -> T
\end{code}

\section{Algebras}

Before we set out to show that induction implies homotopy initiality
and vice versa, we need to define exactly what we mean when we talk
about these concepts. First we will define the relevant concepts for
ordinary |F|-algebras and later give the definitions of algebras for
\ronehits.

The type of \emph{|F|-algebras}, or simply \emph{algebras}, can be
defined as follows:

\begin{code}
  Alg := (X : Type) × (θ : F X -> X)
\end{code}

where the type of algebra morphisms is defined as functions between
the carriers such that it respects both algebra structures:

\begin{code}
  Alg-hom : Alg -> Alg -> Type
  Alg-hom (X , θ) (Y , ρ) :=
       (f : X -> Y)
    ×  (f-β0 : (x : F X) -> f (θ x) == ρ (F f x))
\end{code}

The witness of commutativity has suggestively been named |f-β0| as
this corresponds the computation rule for the recursion and induction
principles.

\subsection{Homotopy initial algebras}

We call an algebra |(X , θ)| \emph{homotopy initial} if it has the
property that for every algebra |(Y , ρ)|, |Alg-hom (X , θ) (Y , ρ)|
is contractible, \ie:

\begin{code}
  is-initial : Alg -> Type
  is-initial θ  :=  (ρ : Alg) → is-contr (Alg-hom θ ρ)
                =   (ρ : Alg) → (f : Alg-hom θ ρ) × ((g : Alg-hom θ ρ) → f == g)
\end{code}

Note that this definition does not refer to how |Alg| and |Alg-hom|
are defined exactly, so this definition also holds for the algebras
for \ronehits.

\subsubsection{Equality of algebra morphisms}

As we see in the definition of homotopy initiality, we need to be able
to talk about equality of algebra morphisms. Given algebras |(X , θ)|
and |(Y , ρ)| and morphisms |(f , f-β0)| and |(g , g-β0)| between
them, we know that, by equality on Σ-types, the following holds:

\begin{code}
   (f , f-β0) == (g , g-β0)
≃  (p : f == g) 
×  (p-β0 : transport (λ h . (x : F X) → h (θ x) == ρ (F h x)) f-β0 == g-β0)
\end{code}

We not only need to show that the functions |f| and |g| are equal, but
also that their β-laws are in some sense compatible with eachother,
respecting the equality |f == g|.

As it turns out, the above is equivalent to something which is more
convenient in subsequent proofs:

\begin{code}
   transport (λ h . (x : F X) → h (θ x) == ρ (F h x)) p f-β0 == g-β0

≃ { transport over Π-types } 

   (λ x . transport (λ h . h (θ x) == ρ (F h x)) p (f-β0 x)) == g-β0

≃ { function extensionality }

   ((x : A) → transport (λ h . h (θ x) == ρ (F h x)) p (f-β0 x) == g-β0 x)

≃ { transporting over equalities }

   ! (ap (λ h . h (θ x)) p) ∙ f-β0 x ∙ ap (λ h . ρ (F h x)) p == g-β0 x

≃ { path algebra }
  
  f-β0 x ∙ ap (λ h . ρ (F h x)) p == ap (λ h . h (θ x)) p ∙ g-β0 x

\end{code}

The last equation tells us that showing that two algebra morphisms are
equal is somewhat like giving a dialgebra morphism from the witness of
the β-law for |f| to that of |g|, as we can see if we draw the
corresponding diagram:

\begin{center}
  \begin{tikzpicture}[description/.style={fill=white,inner sep=2pt}]
    \matrix (m) [matrix of math nodes, 
                row sep=4.5em,
                column sep=3.5em,
                text height=1.5ex,
                text depth=0.25ex]
 { |f (θ x)| & & |ρ (F f x)| \\
   |g (θ x)| & & |ρ (F g x)| \\ };

  \path[->] (m-1-1) edge[decorate] node[auto]       {|f-β0 x|} (m-1-3);
  \path[->] (m-1-3) edge[decorate] node[auto]       {|ap (λ h . ρ (F h x)) p|} (m-2-3);
  \path[->] (m-1-1) edge[decorate] node[auto,swap]  {|ap (λ h . h (θ x)) p|} (m-2-1);
  \path[->] (m-2-1) edge[decorate] node[auto]       {|g-β0 x|} (m-2-3);
  \end{tikzpicture}
\end{center}

\subsection{Algebras for \ronehit descriptions}

For algebras of \ronehits, the structure starts out similar to the
above with an added function for the \oneconstructor. 

\begin{code}
  Alg :=  
       (X : Type)
    ×  (θ0 : F0 X -> X) 
    ×  (θ1 : (x : F1 X) -> l (θ0 * x) == r (θ0 * x))
\end{code}

Recall that |θ0| is an |F0|-algebra and |θ1| is a dependent dialgebra
by defining the target functor |G|:

\begin{code}
  G : ∫ F0-alg F1 -> Type
  G ((X , θ) , x) := (l (θ0 * x) == r (θ0 * x))
\end{code}

Its hom-types can be defined as follows:

\begin{code}
  Alg-hom : Alg -> Alg -> Type
  Alg-hom (X , θ) (Y , ρ) :=
       (f : X -> Y)
    ×  (f-β0 : (x : F0 X) ->       f     (θ0 x)  == ρ0 (F0 f x))
    ×  (f-β1 : (x : F1 X) ->  G x  f,f0  (θ1 x)  == ρ1 (F1 f x))
\end{code}



\subsubsection{Equality of algebra morphisms}

As we saw previously, we also need to consider what equalities of
algebra morphisms look like.

\begin{center}
  \begin{tikzpicture}[description/.style={fill=white,inner sep=2pt}]
    \matrix (m) [matrix of math nodes, 
                row sep=4.5em,
                column sep=3.5em,
                text height=1.5ex,
                text depth=0.25ex]
 { |f (θ0 x)| & & |ρ0 (F0 f x)| \\
   |g (θ0 x)| & & |ρ0 (F0 g x)| \\ };

  \path[->] (m-1-1) edge[decorate] node[auto]       {|f-β0 x|} (m-1-3);
  \path[->] (m-1-3) edge[decorate] node[auto]       {|ap (λ h . ρ0 (F h x)) p|} (m-2-3);
  \path[->] (m-1-1) edge[decorate] node[auto,swap]  {|ap (λ h . h (θ0 x)) p|} (m-2-1);
  \path[->] (m-2-1) edge[decorate] node[auto]       {|g-β0 x|} (m-2-3);
  \end{tikzpicture}
\end{center}

along with

\begin{center}
  \begin{tikzpicture}[description/.style={fill=white,inner sep=2pt}]
    \matrix (m) [matrix of math nodes, 
                row sep=4.5em,
                column sep=3.5em,
                text height=1.5ex,
                text depth=0.25ex]
 { |G x  f,f0  (θ1 x)| & & |ρ1 (F1 f x)| \\
   |G x  g,g0  (θ1 x)| & & |ρ1 (F1 g x)| \\ };

  \path[->] (m-1-1) edge[decorate] node[auto]       {|f-β1 x|} (m-1-3);
  \path[->] (m-1-3) edge[decorate] node[auto]       {|ap (λ (h,h0) . ρ1 (F h x)) (p,p0)|} (m-2-3);
  \path[->] (m-1-1) edge[decorate] node[auto,swap]  {|ap (λ (h,h0) . G x  (h,h0)  (θ1 x) (p,p0)|} (m-2-1);
  \path[->] (m-2-1) edge[decorate] node[auto]       {|g-β1 x|} (m-2-3);
  \end{tikzpicture}
\end{center}


\section{Induction}

Now we know what the algebras for \ronehits look like, characterising
\ronehits as an initial algebra tells us what the constructors look
like and gives us a recursion principle with its computation
rule. However, it does not immediately reveal to us what the induction
principle looks like.

Let us first look at the induction principle for natural numbers:

\begin{code}
  Nat-ind : 
        (P : Nat -> Type)
        (m-zero : P zero)
        (m-succ : (n : Nat) -> P n -> P (succ n))
    ->  (n : Nat) -> P n
\end{code}

In order to show that the predicate |P| holds for every |n : Nat|, we
have to give a method for every constructor, which shows that |P|
holds for that constructor, given that it holds for all its subterms.

Generalising this to an inductive type |T|, given by a container |F :
Type -> Type| and constructor |c : F T -> T|, we get:

\begin{code}
  ind :
        (P : T -> Type)
        (m : (x : F T) -> □ F B x -> B (c x))
    ->  (x : T) -> P x 
\end{code}

with computation rule:

\begin{code}
  ind-β :
        (P : T -> Type)
        (m : (x : F T) -> □ F B x -> B (c x))
        (x : F T)
    ->  ind P m (c x) == m x (□-lift F B (ind P m) x)
\end{code}

The modality |□| lifts the predicate |P| on |T| to a predicate on |F
T|:

\begin{code}
  □ F P : F T -> Type
  □ F P (s , t) := (p : Pos s) -> B (t p)
\end{code}

where |Pos| is the position type of the container |F|. The type |□ F B
x| can be interpreted as: the predicate |P| holds for all of the
subterms of |c x : T|. |□-lift| lifts dependent functions:

\begin{code}
  □-lift : ((x : A) -> B x) -> (x : F A) -> □ F B x
\end{code}

The induction principle gives us a dependent function |(x : T) -> P t|
for a family |P : T -> Type|. Equivalently, we can ask for a section
|σ : B -> T| of a function |p : T -> B| for some |B : Type|. For any
algebra |(B , θ)|, initiality gives us an algebra morphism |σ : (T, c)
-> (B, θ)|. We can ask ourselves what extra conditions we need to
impose on the algebra |(B , θ)| in order for |σ| to be a section of
|p|. If |p| turns out to be an algebra morphism |(B, θ) -> (T, c)|,
then the following diagram commutes:

\begin{center}
  \begin{tikzpicture}[description/.style={fill=white,inner sep=2pt}]
    \matrix (m) [matrix of math nodes, 
                row sep=4.5em,
                column sep=3.5em,
                text height=1.5ex,
                text depth=0.25ex]
 { |FT| & & |T| \\
   |FB| & & |B| \\ 
   |FT| & & |T| \\ };

  \path[->] (m-1-1) edge[decorate] node[auto]       {|c|}  (m-1-3);
  \path[->] (m-1-3) edge[decorate] node[auto]       {|σ|}  (m-2-3);
  \path[->] (m-1-1) edge[decorate] node[auto,swap]  {|Fσ|} (m-2-1);
  \path[->] (m-2-1) edge[decorate] node[auto]       {|θ|}  (m-2-3);
  \path[->] (m-2-3) edge[decorate] node[auto]       {|p|}  (m-3-3);
  \path[->] (m-2-1) edge[decorate] node[auto,swap]  {|Fp|} (m-3-1);
  \path[->] (m-3-1) edge[decorate] node[auto]       {|c|}  (m-3-3);
  \end{tikzpicture}
\end{center}

|p ∘ σ| is an algebra morphism |(T, c) -> (T, c)|. Since |id| is also
an algebra morphism |(T, c) -> (T, c)|, by uniqueness we can conclude
that |p ∘ σ == id|, so |σ| is indeed a section.

By choosing |B := Σ T P| and |p := π0|, we can derive the induction
principle mentioned above, observing that |F (Σ T P) ≃ Σ (FT) (□ F P)|.

\subsection{Induction principle for \ronehits}

An induction principle for \ronehits can be derived using the method
mentioned previously: the data for induction should be an algebra
structure on |Σ T P| such that |π0| is an algebra morphism |(Σ T P ,
π0 , G π0) -> (T , c0 , c1)|. We have to produce the methods:

\begin{code}
  m0 : F0 (Σ T P) -> Σ T P
  m1 : (x : F1 (Σ T P)) -> G (Σ T P , m0) x
\end{code}

subject to the equations:

\begin{code}
  m-β0 : (x : F0 (Σ T P)) -> π0 (m0 x) == c0 (F0 π0 x)
  m-β1 : (x : F1 (Σ T P)) -> G (π0 , m-β0) (m1 x) == c1 (F1 π0 x)
\end{code}

From this we can make derive the methods for the induction principle:

\begin{code}
  m0 : (x : F0 T) -> □ F0 P x -> P (c0 x)
  m1 : (x : F1 T) (y : □ F1 P x) -> m0 *ᵈ (lᵈ x y) == m0 *ᵈ (rᵈ x y) [ P ↓ c1 x ]
\end{code}

where:

\begin{code}
  lᵈ, rᵈ  : {A : Type0} {B : A -> Type0} 
          -> (x : F1 A) -> □ F1 B x -> Σ (F0 *) (□ (F0 *) B)
\end{code}

and

\begin{code}
  m0 *ᵈ : (x : Σ (F0 *)) × □ (F0 *) P x -> P (c0 (π0 x))
\end{code}

are the liftings of their non-dependent counterparts.

\section{Induction implies homotopy initiality}

We want to show that, given |T : Type| and |c : F T -> T| that
satisfies the induction principle, the algebra |(T , c)| is initial,
\ie for any algebra |(X , θ)|, |Alg-hom (T , c) (X , θ) ≃ 1|. We will
first show that we have an algebra morphism |f : (T , c) -> (X , θ)|
and will then show that this algebra morphism is unique.

\subsection{W-types}

\subsubsection{Existence}

We can use the induction principle to produce the algebra morphism we want:

\begin{code}
  f : T -> X
  f := ind (λ x . X) (λ (s , _) t . θ (s , t))
\end{code}

The computation rule is then given directly by the computation rule
for the induction rule:

\begin{code}
  f0 : (x : F T) -> f (θ x) == θ (F f x)
  f0 := ind-β
\end{code}

\subsubsection{Uniqueness}

Assuming that we have an algebra morphism |(g , g0) : (T , c) -> (X ,
θ)|, we need to show that |(f , f0) == (g , g0)|. Showing that the |f
== g| can be done by induction, using the motive |λ x . f x == g
x|. The induction step is then proven as follows:

\begin{code}
  step : (x : ⟦ F ⟧0 T) → □ F (λ x . f x == g x) x → f=g-B (c x)
  step x u :=
    f (c x)
     =⟪ f0 x ⟫
    θ (⟦ F ⟧1 f x)
     =⟪ ap θ (ind-hyp x u) ⟫
    θ (⟦ F ⟧1 g x)
     =⟪ ! (g0 x) ⟫
    g (c x) ∎
\end{code}

where |ind-hyp : (x : F T) → □ F (λ x . f x == g x) x → F f x == F g
x|. We can define the witness of |f == g| as follows:

\begin{code}
  p : (x : T) -> f x == g x
  p := ind (λ x . f x == g x) step
\end{code}

which comes with the computation rule:

\begin{code}
  p-β0 : (x : FT) -> p (c x) == f-β0 x ∙ ap θ (ind-hyp x (□-lift F p x)) ∙ ! (g-β0 x)
\end{code}

We now need to show that our witness |p| satisfies the ``computation
rule'' |(x : FT) -> f-β0 x ∙ ap (λ h . ρ (F h x)) p == ap (λ h . h (θ
x)) p ∙ g-β0 x|. Let |x : FT|, then we can calculate:

\begin{code}
  f-β0 x ∙ ap (λ h . θ (F h x)) (fun-ext p)

   == { ap magic }

  f-β0 x ∙ ap θ (ind-hyp x (□-lift F p x))

   == { symmetry is involutive }

  f-β0 x ∙ ap θ (ind-hyp x (□-lift F p x)) ∙ ! (g-β0 x) ∙ g-β0 x

   == { computation rule for p }

  p (c x) ∙ g-β0 x

   == { computation rule for fun-ext }

  ap (λ h . h (c x)) (fun-ext p) ∙ g-β0 x   
\end{code}

We have now established initiality of |(T , c)|.

\subsection{\Ronehits}

\subsubsection{Existence}

\subsubsection{Uniqueness}

\section{Thesis outline}

\end{document}