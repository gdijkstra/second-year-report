\documentclass[a4paper,10pt]{article}

\usepackage{color}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}


%% Encoding, font stuff
\usepackage[utf8x]{inputenc}
\usepackage{autofe}
\usepackage{ucs}
\usepackage[greek,english]{babel}
\usepackage{bbm}
\usepackage{bbding}

%% Symbols and whatever
\usepackage{amsmath,amsthm,amssymb,amsfonts,stmaryrd}

%include note.fmt

%% Layout stuff and other related goodies.
\usepackage[parfill]{parskip}
\usepackage{xspace}
\usepackage{todonotes}


%% URLs and other link stuff
\usepackage{url}
\usepackage{hyperref}
\usepackage[noabbrev]{cleveref}

\hypersetup{
  colorlinks,
  citecolor=DarkBlue,
  linkcolor=black,
  urlcolor=DarkBlue}

% Bibliography stuff
\usepackage[autostyle]{csquotes}

%% Commands
\newcommand{\todoi}[1]{\todo[inline]{#1}}
\newcommand{\withoutk}{\xspace\verb+--without-K+\xspace}
\newcommand{\uip}{uniqueness of identity proofs\xspace}
\newcommand{\Uip}{Uniqueness of identity proofs\xspace}
\newcommand{\hott}{homotopy type theory\xspace}
\newcommand{\Hott}{Homotopy type theory\xspace}
\newcommand{\mltt}{Martin-L\"of's type theory\xspace}
\newcommand{\hit}{higher inductive type\xspace}
\newcommand{\Hit}{Higher inductive type\xspace}
\newcommand{\hits}{higher inductive types\xspace}
\newcommand{\Hits}{Higher inductive types\xspace}
\newcommand{\oit}{ordinary inductive type\xspace}
\newcommand{\Oit}{Ordinary inductive type\xspace}
\newcommand{\oits}{ordinary inductive types\xspace}
\newcommand{\Oits}{Ordinary inductive types\xspace}
\newcommand{\zeroconstructor}{$0$-constructor\xspace}
\newcommand{\zeroconstructors}{$0$-constructors\xspace}
\newcommand{\onehit}{$1$-HIT\xspace}
\newcommand{\onehits}{$1$-HITs\xspace}
\newcommand{\oneconstructor}{$1$-constructor\xspace}
\newcommand{\oneconstructors}{$1$-constructors\xspace}
\newcommand{\twohit}{$2$-HIT\xspace}
\newcommand{\twohits}{$2$-HITs\xspace}
\newcommand{\twoconstructor}{$2$-constructor\xspace}
\newcommand{\twoconstructors}{$2$-constructors\xspace}
\newcommand{\zerovariable}{$0$-variable\xspace}
\newcommand{\onevariable}{$1$-variable\xspace}
\newcommand{\twovariable}{$2$-variable\xspace}
\newcommand{\zerovariables}{$0$-variables\xspace}
\newcommand{\onevariables}{$1$-variables\xspace}
\newcommand{\twovariables}{$2$-variables\xspace}
\newcommand{\ie}{i.e.\xspace}
\newcommand{\eg}{e.g.\xspace}
\newcommand{\Type}{\mbox{Type}}
\newcommand{\wtypes}{$W$-types\xspace}
\newcommand{\wtype}{$W$-type\xspace}
\newcommand{\ronehit}{restricted \onehit\xspace}
\newcommand{\ronehits}{restricted \onehits\xspace}
\newcommand{\Ronehit}{Restricted \onehit\xspace}
\newcommand{\Ronehits}{Restricted \onehits\xspace}

\title{Notes on \onehits}

\author{Gabe Dijkstra}

\date{}

\begin{document}

\maketitle

\section{Introduction}

\section{Describing \hits}

If we define an ordinary inductive type, we start out by writing down
a list of constructors, \eg:

\begin{code}
  data T : Type where
    c0  : F0 T -> T
    c1  : F1 T -> T
        vdots
    ck  : Fk T -> T
\end{code}

where all |Fi : Type -> Type| are strictly positive
functors. Equivalently, we can define an inductive type with a single
constructor:

\begin{code}
  data T : Type where
    c : F T -> T
\end{code}

where |F X := F0 X + F1 X + hdots + Fk X|, so a single strictly
positive functor is all we need to describe an \oit.

In the case of \hits, the situation is more involved. Consider for
example the circle data type:

\begin{code}
  data S1 : Type where
    base : S1
    loop : base == base
\end{code}

There are two things that are different from our previous
situation. Firstly, the result type of |loop| is not |S1|, but a path
space of |S1|: constructors are no longer algebras of functor, but a
kind of \emph{dialgebra}: the arguments as well as the result type of
a constructor may vary. Secondly, the |loop| constructor refers to the
previous constructor |base|.

The result type of a constructor can also depend on the value of its
arguments, as we see in the definition of propositional truncation as
a \hit:

\begin{code}
  data // A // : Type where
    [_] : A -> // A //
    trunc : (x y : // A //) -> x == y
\end{code}

Constructors of a \hit are \emph{dependent dialgebras}. In general, a
higher inductive type looks as follows:

\begin{code}
  data T : Type where
    c0    : (x : F0 T)              -> G0 T x
    c1    : (x : F1 T c0)           -> G1 T c0 x
    c2    : (x : F2 T c0 c1)        -> G2 T c0 c1 x
          vdots
    ck+1  : (x : Fk T c0 hdots ck)  -> Gk T c0 hdots ck x
\end{code}

We will refer to the |Fi| functors as \emph{argument} functors and the
|Gi| functors as \emph{target} functors. The types of the argument
functors are:

\begin{code}
F0   : Type          -> Type
F1   : (F0, G0)-alg  -> Type       
F2   : (F1, G1)-alg  -> Type       
Fk+1 : (Fk, Gk)-alg  -> Type
\end{code}

where |(F0, G0)-alg)| is the category whose objects are dependent
dialgebras |(X : Type) × (θ : (x : F0 X) -> G0 X x)|. The category
|(F(i+1),G(i+1)-alg|has as objects: |(X : (Fi, Gi)-alg) × (θ : (x :
F(i+1) X) -> G(i+1) X x)|. The target functors also take the value of
the arguments as an argument, so they have the following types:

\begin{code}
G0    : int Type          F0      -> Type
G1    : int (F0, G0)-alg  F1      -> Type       
G2    : int (F1, G1)-alg  F2      -> Type       
Gk+1  : int (Fk, Gk)-alg  F(k+1)  -> Type
\end{code}

We see that the general shape of a constructor is a dependent dialgebra:

\begin{code}
  c : (x : F X) -> G (X , x)
\end{code}

where |C : Cat|, |F : C -> Type| and |G : int C F -> Type|, where |C|
is |Type| or some category of dependent dialgebras.

When describing \hits, we do not allow for any target functor |G|: it
must either return the type we are defining or a (possibly iterated)
path space of that type.

A \emph{\zeroconstructor} or \emph{point constructor} is a dialgebra:

\begin{code}
  c : (x : F X) -> U X
\end{code}

where |C : Cat|, |F : C -> Type| and |U : C -> Type| its forgetful
functor.

A \emph{\oneconstructor} is a dependent dialgebra of which the target
functor returns a path space:

\begin{code}
  c : (x : F X) -> Eq0 X x
\end{code}

where |C : Cat|, |F, U : C -> Type|, and |Eq0 : int C F -> Type| is the functor:

\begin{code}
  Eq0 (X , x) := (l0 X x == r0 X x)
\end{code}

where |l0, r0 : F -> U| are natural transformations.

For higher path constructors, we have to specify a tower of natural
transformations, specifying the end points at every level. To specify
an |(n+1)|-constructor, we need to give the natural transformations:

\begin{code}
  l0, r0  : F -> U
  l1, r1  : 1 -> Eq0
  l2, r2  : 1 -> Eq1
          vdots
  ln, rn  : 1 -> Eqn-1
\end{code}

where |Eqi X x := (li X x == ri X x)|. |Eqn| is then the target
functor we are interested in.

\subsection{Strict positivity}

Apart from the restrictions on targets, we also want all functors
involved to be strictly positive. In the case of \oits, we also have
this restriction. An example of an inductive type which constructor is
not strictly positive is the following:

\begin{code}
  data Term : Type where
    lam : (Term -> Term) -> Term
\end{code}

Using the type |Term|, we can find inhabitants of the empty type. We
therefore only consider inductive types defined by strictly positive
functors, \ie containers. Containers however only describe functors
|Type -> Type|. An example of that shows that we need a notion of
strict positivity for any functor into |Type| is that of the ``initial
field''. If we write down the axioms of an algebraic structure as
constructors, the inductive type we get is then the initial object in
the category of that algebraic structure, \ie  we can define a type |T|
with the monoid axioms as constructors:

\begin{code}
  data T : Type where
    uip : (x y : T) (p q : x == y) -> p == q
    _∙_ : T -> T -> T
    assoc : (x y z : T) -> (x ∙ y) ∙ z == x ∙ (y ∙ z)
    e : T
    e-unit-l : (x : T) -> e ∙ x == x
    e-unit-r : (x : T) -> x ∙ e == x
\end{code}

|T| is equivalent to the unit type, which is the initial object in the
category of monoids. If we now were to write down the axioms of a
field, we run into trouble: there is no initial object in the category
of fields. The culprit is the inverse operation, which has the type:

\begin{code}
  inv : (x : T) -> (x == 0 -> ⊥) -> T
\end{code}

The constructor |0| occurs negatively in this constructor.

To generalise the notion of strict positivity, we can generalise the
notion of containers to not only describe functors |Type -> Type|, but
functors \emph{into} |Type| from any |C : Cat|. A \emph{generalised
  container} is given by:

\begin{code}
  S : Type
  P : S -> / C /
\end{code}

Its extension is then defined as:

\begin{code}
  ⟦ S ◁ P ⟧ : C -> Type
  ⟦ S ◁ P ⟧ X := (s : S) × C(P s, X)
\end{code}

with the action on morphisms defined as:

\begin{code}
  ⟦ F ⟧ : C(X , Y) -> ⟦ F ⟧ X -> ⟦ F ⟧ Y
  ⟦ F ⟧ f (s , t) := (s , f ∘ t)
\end{code}


\subsection{\Hits as a sequence of monads}


\section{\Ronehits}

\todoi{coherence and other reasons why things are difficult}

\section{Algebras}

The type of \emph{|F|-algebras}, or simply \emph{algebras}, can be
defined as follows:

\begin{code}
  Alg := (X : Type) × (θ : F X -> X)
\end{code}

where the type morphisms is defined as follows:

\begin{code}
  Alg-hom : Alg -> Alg -> Type
  Alg-hom (X , θ) (Y , ρ) :=
       (f : X -> Y)
    ×  (f-β₀ : (x : F X) -> f (θ x) == ρ (F f x))
\end{code}

The witness of commutativity has suggestively been named |f-β₀| as
this gives us the |β|-rule for the recursion and induction principles.

\todoi{Something about having |f₀ : f ∘ θ = ρ ∘ F f| instead. We need
  function extensionality either way, but this way it makes the
  arguments later on a bit easier. Also, the dependent versions don't
  work as pointfree as these ones}

\subsection{Homotopy initial algebras}

We call an algebra |(X , θ)| \emph{homotopy initial} if it has the
property that for every algebra |(Y , ρ)|, |Alg-hom (X , θ) (Y , ρ)|
is contractible, \ie:

\begin{code}
  is-initial : Alg -> Type
  is-initial θ  :=  (ρ : Alg) → is-contr (Alg-hom θ ρ)
                =   (ρ : Alg) → (f : Alg-hom θ ρ) × ((g : Alg-hom θ ρ) → f == g)
\end{code}

\subsubsection{Equality of algebra morphisms}

As we see in the definition of homotopy initiality, we need to be able
to talk about equality of algebra morphisms. Given algebras |(X , θ)|
and |(Y , ρ)| and morphisms |(f , f-β₀)| and |(g , g-β₀)| between
them, we know that, by equality on Σ-types, the following holds:

\begin{code}
   (f , f-β₀) == (g , g-β₀)
≃  (p : f == g) 
×  (p-β₀ : transport (λ h . (x : F X) → h (θ x) == ρ (F h x)) f-β₀ == g-β₀)
\end{code}

We not only need to show that the functions |f| and |g| are equal, but
also that their β-laws are in some sense compatible with eachother,
respecting the equality |f == g|.

As it turns out, the above is equivalent to something which is more
convenient in subsequent proofs:


\begin{code}
   transport (λ h → (x : F X) → h (θ x) == ρ (F h x)) p f-β₀ == g-β₀

≃ { transport over Π-types } 

   (λ x → transport (λ h → h (θ x) == ρ (F h x)) p (f-β₀ x)) == g-β₀

≃ { function extensionality }

   ((x : A) → transport (λ h → h (θ x) == ρ (F h x)) p (f-β₀ x) == g-β₀ x)

≃ { transporting over equalities }

   ! (ap (λ h → h (θ x)) p) ∙ f-β₀ x ∙ ap (λ h → ρ (F h x)) p == g-β₀ x

≃ { path algebra }
  
  f-β₀ x ∙ ap (λ h → ρ (F h x)) p == ap (λ h → h (θ x)) p ∙ g-β₀ x

\end{code}

The last equation tells us that showing that two algebra morphisms are
equal is somewhat like giving an algebra morphism from the witness of
the β-law for |f| to that of |g|, as we can see if we draw the
corresponding diagram:

\todoi{comm diag}

\subsection{Algebras for \ronehit descriptions}

\begin{code}
  Alg :=  
       (X : Type)
    ×  (θ₀ : F₀ X -> X) 
    ×  (θ₁ : (x : F₁ X) -> l (θ₀ * x) == r (θ₀ * x))
\end{code}

|θ₀| is an |F₀|-algebra and |θ₁| can be seen as a dependent dialgebra
by defining the functor |G₁|:

\begin{code}
  G₁ : ∫ F₀-Algebra F₁ -> Type
  G₁ ((X , θ) , x) := (l (θ₀ * x) == r (θ₀ * x))
\end{code}

Its hom-types can be defined as follows:

\begin{code}
  Alg-hom : Alg -> Alg -> Type
  Alg-hom (X , θ) (Y , ρ) :=
       (f : X -> Y)
    ×  (f-β₀ : (x : F₀ X) ->       f     (θ₀ x)  == ρ₀ (F₀ f x))
    ×  (f-β₁ : (x : F₁ X) -> G₁ x  f,f₀  (θ₁ x)  == ρ₁ (F₁ f x))
\end{code}


\section{Induction}

Given a functor |F : Type -> Type| given as a container |F := S
◁ P|, the \wtype |W| is defined as having the following
introduction rule / constructor:

\begin{code}
  c : F W -> W
\end{code}

as well as an elimination rule / induction principle:

\begin{code}
  ind :   
       (B : W -> Type)
       (m : (x : F W) → □ F B x → B (c x))
       (x : W) 
   ->  B x

\end{code}

with computation rule:

\begin{code}
  ind-β₀ :
       (B : W -> Type) 
       (m : (x : F W) → □ F B x → B (c x))
       (x : F W)
   ->  ind B m (c x) == m x (□-lift F (ind B m) x)
\end{code}

\subsection{Initiality implies induction}

The induction principle tells us that for a family |B : W -> Type| and
a motive |m : (x : F W) → □ F B x → B (c x)|, we get a dependent
function |ind : (x : W) -> B x| along with a computation rule.

Note that |m|, along with |c|, can be seen as a morphism between the
families |(W , B)| and |(F W , □ F B)|.

Another way to say this is that given a function |p : B -> W| for some
|B : Type| and that we want |θ : F B -> B| such that |θ|, along with
|c|, becomes a morphism |Fp -> p| in the arrow category. This is
equivalent to asking for an algebra |(B , θ)| along with an algebra
morphism |(B , θ) -> (W , c)|.

\todoi{Give arguments why section induction is correct}

\todoi{Show that initiality implies section induction}

\subsection{Induction principle for \ronehits}

To get the induction principle of \ronehits, we need to take that of
the ordinary \wtypes and extend it with the new (path) constructor: we
have to add a method to |ind| and the appropriate computation rule for
that.

Consider the method for the \zeroconstructor:

\begin{code}
  m₀ : (x : F₀ X) -> □ F₀ B x -> B (c₀ x)
\end{code}

We can read this as showing that if for all subterms of |c₀ x| |B|
holds, |B| also holds for |c₀ x| itself. Since we are dealing with a
\zeroconstructor, we don't have any issues with the target of the
constructor: the target functor is the identity functor. For the
motive of the \oneconstructor, we want something like:

\begin{code}
  m₁ : (x : F₁ X) -> □ F₁ B x -> □ G (c₁ x)
\end{code}

We need to figure out what the lifting of |B| to the target functor
|G| is.

\section{Induction implies homotopy initiality}

We want to show that, given |T : Type| and |c : F T -> T| that
satisfies the induction principle, the algebra |(T , c)| is initial,
\ie for any algebra |(X , θ)|, |Alg-hom (T , c) (X , θ) ≃ 1|. We will
first show that we have an algebra morphism |f : (T , c) -> (X , θ)|
and will then show that this algebra morphism is unique.

\subsection{W-types}

\subsubsection{Existence}

We can use the induction principle to produce the algebra morphism we want:

\begin{code}
  f : T -> X
  f := ind (λ x -> X) (λ (s , _) t -> θ (s , t))
\end{code}

The computation rule is then given directly by the computation rule
for the induction rule:

\begin{code}
  f₀ : (x : F T) -> f (θ x) == θ (F f x)
  f₀ := ind-β
\end{code}

\subsubsection{Uniqueness}

Assuming that we have an algebra morphism |(g , g₀) : (T , c) -> (X ,
θ)|, we need to show that |(f , f₀) == (g , g₀)|. Showing that the |f
== g| can be done by induction, using the motive |λ x -> f x == g
x|. The induction step is then proven as follows:

\begin{code}
  step : (x : ⟦ F ⟧₀ T) → □ F f=g-B x → f=g-B (c x)
  step x u :=
    f (c x)
     =⟪ f₀ x ⟫
    θ (⟦ F ⟧₁ f x)
     =⟪ ap θ (ind-hyp x u) ⟫
    θ (⟦ F ⟧₁ g x)
     =⟪ ! (g₀ x) ⟫
    g (c x) ∎
\end{code}

\todoi{Explain |ind-hyp|}

We can define the witness of |f == g| as follows:

\begin{code}
  p : (x : T) -> f x == g x
  p := ind (λ x -> f x == g x) step
\end{code}

which comes with the computation rule:

\begin{code}
  p-β₀ : (x : FT) -> p (c x) == f-β₀ x ∙ ap θ (ind-hyp x (□-lift F p x)) ∙ ! (g-β₀ x)
\end{code}

\todoi{say that |λ=| is fun ext}

We now need to show that our witness |p| satisfies the ``computation
rule'' |(x : FT) -> f-β₀ x ∙ ap (λ h → ρ (F h x)) p == ap (λ h → h (θ
x)) p ∙ g-β₀ x|. Let |x : FT|, then we can calculate:

\begin{code}
  f-β₀ x ∙ ap (λ h → θ (F h x)) (λ= p)

   == { ap magic }

  f-β₀ x ∙ ap θ (ind-hyp x (□-lift F p x))

   == { symmetry is involutive }

  f-β₀ x ∙ ap θ (ind-hyp x (□-lift F p x)) ∙ ! (g-β₀ x) ∙ g-β₀ x

   == { computation rule for p }

  p (c x) ∙ g-β₀ x

   == { computation rule for λ= }

  ap (λ h → h (c x)) (λ= p) ∙ g-β₀ x   
\end{code}

We have now established initiality of |(T , c)|.

\subsection{\Ronehits}

\subsubsection{Existence}

\subsubsection{Uniqueness}

\end{document}