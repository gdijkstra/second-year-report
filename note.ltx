\documentclass[a4paper,10pt]{article}

\usepackage{color}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}


%% Encoding, font stuff
\usepackage[utf8x]{inputenc}
\usepackage{autofe}
\usepackage{ucs}
\usepackage[greek,english]{babel}
\usepackage{bbm}
\usepackage{bbding}

%% Symbols and whatever
\usepackage{amsmath,amsthm,amssymb,amsfonts,stmaryrd}

%include note.fmt

%% Layout stuff and other related goodies.
\usepackage[parfill]{parskip}
\usepackage{xspace}
\usepackage{todonotes}


%% URLs and other link stuff
\usepackage{url}
\usepackage{hyperref}
\usepackage[noabbrev]{cleveref}

\hypersetup{
  colorlinks,
  citecolor=DarkBlue,
  linkcolor=black,
  urlcolor=DarkBlue}

% Bibliography stuff
\usepackage[autostyle]{csquotes}

%% Commands
\newcommand{\todoi}[1]{\todo[inline]{#1}}
\newcommand{\withoutk}{\xspace\verb+--without-K+\xspace}
\newcommand{\uip}{uniqueness of identity proofs\xspace}
\newcommand{\Uip}{Uniqueness of identity proofs\xspace}
\newcommand{\hott}{homotopy type theory\xspace}
\newcommand{\Hott}{Homotopy type theory\xspace}
\newcommand{\mltt}{Martin-L\"of's type theory\xspace}
\newcommand{\hit}{higher inductive type\xspace}
\newcommand{\Hit}{Higher inductive type\xspace}
\newcommand{\hits}{higher inductive types\xspace}
\newcommand{\Hits}{Higher inductive types\xspace}
\newcommand{\oit}{ordinary inductive type\xspace}
\newcommand{\Oit}{Ordinary inductive type\xspace}
\newcommand{\oits}{ordinary inductive types\xspace}
\newcommand{\Oits}{Ordinary inductive types\xspace}
\newcommand{\zeroconstructor}{$0$-constructor\xspace}
\newcommand{\zeroconstructors}{$0$-constructors\xspace}
\newcommand{\onehit}{$1$-HIT\xspace}
\newcommand{\onehits}{$1$-HITs\xspace}
\newcommand{\oneconstructor}{$1$-constructor\xspace}
\newcommand{\oneconstructors}{$1$-constructors\xspace}
\newcommand{\twohit}{$2$-HIT\xspace}
\newcommand{\twohits}{$2$-HITs\xspace}
\newcommand{\twoconstructor}{$2$-constructor\xspace}
\newcommand{\twoconstructors}{$2$-constructors\xspace}
\newcommand{\zerovariable}{$0$-variable\xspace}
\newcommand{\onevariable}{$1$-variable\xspace}
\newcommand{\twovariable}{$2$-variable\xspace}
\newcommand{\zerovariables}{$0$-variables\xspace}
\newcommand{\onevariables}{$1$-variables\xspace}
\newcommand{\twovariables}{$2$-variables\xspace}
\newcommand{\ie}{i.e.\xspace}
\newcommand{\eg}{e.g.\xspace}
\newcommand{\Type}{\mbox{Type}}
\newcommand{\wtypes}{$W$-types\xspace}
\newcommand{\wtype}{$W$-type\xspace}
\newcommand{\ronehit}{restricted \onehit\xspace}
\newcommand{\ronehits}{restricted \onehits\xspace}
\newcommand{\Ronehit}{Restricted \onehit\xspace}
\newcommand{\Ronehits}{Restricted \onehits\xspace}

\title{Notes on \onehits}

\author{Gabe Dijkstra}

\date{}

\begin{document}

\maketitle

\section{Introduction}

\section{Describing \hits}


\section{\Ronehits}



\section{Homotopy initiality for \wtypes}

In type theory, a data type is described by its introduction rule (the
constructors) and its elimination rule (the induction principle) along
with a computation rule describing how these two rules interact.

\todoi{Natural numbers example?}

\subsection{Induction principle}

Given a functor |F : Type -> Type| given as a container |F := S
◁ P|, the \wtype |W| is defined as having the following
introduction rule / constructor:

\begin{code}
  c : F W -> W
\end{code}

as well as an elimination rule / induction principle:

\begin{code}
  ind :   
       (B : W -> Type)
       (m : (x : F W) → □ F B x → B (c x))
       (x : W) 
   ->  B x

\end{code}

with computation rule:

\begin{code}
  ind-β₀ :
       (B : W -> Type) 
       (m : (x : F W) → □ F B x → B (c x))
       (x : F W)
   ->  ind B m (c x) == m x (□-lift F (ind B m) x)
\end{code}

\subsection{Algebras}

The type of \emph{|F|-algebras}, or simply \emph{algebras}, can be
defined as follows:

\begin{code}
  Alg := (X : Type) × (θ : F X -> X)
\end{code}

where the type morphisms is defined as follows:

\begin{code}
  Alg-hom : Alg -> Alg -> Type
  Alg-hom (X , θ) (Y , ρ) :=
       (f : X -> Y)
    ×  (f-β₀ : (x : F X) -> f (θ x) == ρ (F f x))
\end{code}

The witness of commutativity has suggestively been named |f-β₀| as
this gives us the |β|-rule for the recursion and induction principles.

\todoi{Something about having |f₀ : f ∘ θ = ρ ∘ F f| instead. We need
  function extensionality either way, but this way it makes the
  arguments later on a bit easier. Also, the dependent versions don't
  work as pointfree as these ones}

\subsubsection{Homotopy initial algebras}

We call an algebra |(X , θ)| \emph{homotopy initial} if it has the
property that for every algebra |(Y , ρ)|, |Alg-hom (X , θ) (Y , ρ)|
is contractible, \ie:

\begin{code}
  is-initial : Alg -> Type
  is-initial θ  :=  (ρ : Alg) → is-contr (Alg-hom θ ρ)
                =   (ρ : Alg) → (f : Alg-hom θ ρ) × ((g : Alg-hom θ ρ) → f == g)
\end{code}

\subsubsection{Equality of algebra morphisms}

As we see in the definition of homotopy initiality, we need to be able
to talk about equality of algebra morphisms. Given algebras |(X , θ)|
and |(Y , ρ)| and morphisms |(f , f-β₀)| and |(g , g-β₀)| between
them, we know that, by equality on Σ-types, the following holds:

\begin{code}
   (f , f-β₀) == (g , g-β₀)
≃  (p : f == g) 
×  (p-β₀ : transport (λ h . (x : F X) → h (θ x) == ρ (F h x)) f-β₀ == g-β₀)
\end{code}

We not only need to show that the functions |f| and |g| are equal, but
also that their β-laws are in some sense compatible with eachother,
respecting the equality |f == g|.

As it turns out, the above is equivalent to something which is more
convenient in subsequent proofs:


\begin{code}
   transport (λ h → (x : F X) → h (θ x) == ρ (F h x)) p f-β₀ == g-β₀

≃ { transport over Π-types } 

   (λ x → transport (λ h → h (θ x) == ρ (F h x)) p (f-β₀ x)) == g-β₀

≃ { function extensionality }

   ((x : A) → transport (λ h → h (θ x) == ρ (F h x)) p (f-β₀ x) == g-β₀ x)

≃ { transporting over equalities }

   ! (ap (λ h → h (θ x)) p) ∙ f-β₀ x ∙ ap (λ h → ρ (F h x)) p == g-β₀ x

≃ { path algebra }
  
  f-β₀ x ∙ ap (λ h → ρ (F h x)) p == ap (λ h → h (θ x)) p ∙ g-β₀ x

\end{code}

The last equation tells us that showing that two algebra morphisms are
equal is somewhat like giving an algebra morphism from the witness of
the β-law for |f| to that of |g|, as we can see if we draw the
corresponding diagram:

\todoi{comm diag}



\subsection{Initiality implies induction}

The induction principle tells us that for a family |B : W -> Type| and
a motive |m : (x : F W) → □ F B x → B (c x)|, we get a dependent
function |ind : (x : W) -> B x| along with a computation rule.

Note that |m|, along with |c|, can be seen as a morphism between the
families |(W , B)| and |(F W , □ F B)|.

Another way to say this is that given a function |p : B -> W| for some
|B : Type| and that we want |θ : F B -> B| such that |θ|, along with
|c|, becomes a morphism |Fp -> p| in the arrow category. This is
equivalent to asking for an algebra |(B , θ)| along with an algebra
morphism |(B , θ) -> (W , c)|.

\todoi{Give arguments why section induction is correct}

\todoi{Show that initiality implies section induction}

\subsection{Induction implies initiality}

We want to show that, given |T : Type| and |c : F T -> T| that
satisfies the induction principle, the algebra |(T , c)| is initial,
\ie for any algebra |(X , θ)|, |Alg-hom (T , c) (X , θ) ≃ 1|. We will
first show that we have an algebra morphism |f : (T , c) -> (X , θ)|
and will then show that this algebra morphism is unique.

\subsubsection{Existence}

We can use the induction principle to produce the algebra morphism we want:

\begin{code}
  f : T -> X
  f := ind (λ x -> X) (λ (s , _) t -> θ (s , t))
\end{code}

The computation rule is then given directly by the computation rule
for the induction rule:

\begin{code}
  f₀ : (x : F T) -> f (θ x) == θ (F f x)
  f₀ := ind-β
\end{code}

\subsubsection{Uniqueness}

Assuming that we have an algebra morphism |(g , g₀) : (T , c) -> (X ,
θ)|, we need to show that |(f , f₀) == (g , g₀)|. Showing that the |f
== g| can be done by induction, using the motive |λ x -> f x == g
x|. The induction step is then proven as follows:

\begin{code}
  step : (x : ⟦ F ⟧₀ T) → □ F f=g-B x → f=g-B (c x)
  step x u :=
    f (c x)
     =⟪ f₀ x ⟫
    θ (⟦ F ⟧₁ f x)
     =⟪ ap θ (ind-hyp x u) ⟫
    θ (⟦ F ⟧₁ g x)
     =⟪ ! (g₀ x) ⟫
    g (c x) ∎
\end{code}

\todoi{Explain |ind-hyp|}

We can define the witness of |f == g| as follows:

\begin{code}
  p : (x : T) -> f x == g x
  p := ind (λ x -> f x == g x) step
\end{code}

which comes with the computation rule:

\begin{code}
  p-β₀ : (x : FT) -> p (c x) == f-β₀ x ∙ ap θ (ind-hyp x (□-lift F p x)) ∙ ! (g-β₀ x)
\end{code}

\todoi{say that |λ=| is fun ext}

We now need to show that our witness |p| satisfies the ``computation
rule'' |(x : FT) -> f-β₀ x ∙ ap (λ h → ρ (F h x)) p == ap (λ h → h (θ
x)) p ∙ g-β₀ x|. Let |x : FT|, then we can calculate:

\begin{code}
  f-β₀ x ∙ ap (λ h → θ (F h x)) (λ= p)

   == { ap magic }

  f-β₀ x ∙ ap θ (ind-hyp x (□-lift F p x))

   == { symmetry is involutive }

  f-β₀ x ∙ ap θ (ind-hyp x (□-lift F p x)) ∙ ! (g-β₀ x) ∙ g-β₀ x

   == { computation rule for p }

  p (c x) ∙ g-β₀ x

   == { computation rule for λ= }

  ap (λ h → h (c x)) (λ= p) ∙ g-β₀ x   
\end{code}

We have now established initiality of |(T , c)|.

\section{Homotopy initiality for \ronehits}

To establish initiality for \ronehits, we proceed along the same lines
as we have previously for ordinary \wtypes. We first define the
induction principle and the algebras, and show that induction implies
initiality and the other way around.

\subsection{Induction principle}

To get the induction principle of \ronehits, we need to take that of
the ordinary \wtypes and extend it with the new (path) constructor: we
have to add a method to |ind| and the appropriate computation rule for
that.

Consider the method for the \zeroconstructor:

\begin{code}
  m₀ : (x : F₀ X) -> □ F₀ B x -> B (c₀ x)
\end{code}

We can read this as showing that if for all subterms of |c₀ x| |B|
holds, |B| also holds for |c₀ x| itself. Since we are dealing with a
\zeroconstructor, we don't have any issues with the target of the
constructor: the target functor is the identity functor. For the
motive of the \oneconstructor, we want something like:

\begin{code}
  m₁ : (x : F₁ X) -> □ F₁ B x -> □ G (c₁ x)
\end{code}

We need to figure out what the lifting of |B| to the target functor
|G| is.

\subsection{Algebras}

\begin{code}
  Alg :=  
       (X : Type)
    ×  (θ₀ : F₀ X -> X) 
    ×  (θ₁ : (x : F₁ X) -> l (θ₀ * x) == r (θ₀ * x))
\end{code}

|θ₀| is an |F₀|-algebra and |θ₁| can be seen as a dependent dialgebra
by defining the functor |G₁|:

\begin{code}
  G₁ : ∫ F₀-Algebra F₁ -> Type
  G₁ ((X , θ) , x) := (l (θ₀ * x) == r (θ₀ * x))
\end{code}

Its hom-types can be defined as follows:

\begin{code}
  Alg-hom : Alg -> Alg -> Type
  Alg-hom (X , θ) (Y , ρ) :=
       (f : X -> Y)
    ×  (f-β₀ : (x : F₀ X) ->       f     (θ₀ x)  == ρ₀ (F₀ f x))
    ×  (f-β₁ : (x : F₁ X) -> G₁ x  f,f₀  (θ₁ x)  == ρ₁ (F₁ f x))
\end{code}

Initiality for these algebras is defined in the same way as before.

\subsubsection{Equality of algebra morphisms}

\todoi{todo}

\subsection{Initiality implies induction}

\subsection{Induction implies initiality}

\todoi{todo}

\subsubsection{Existence}

\subsubsection{Uniqueness}

\end{document}