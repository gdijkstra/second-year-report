\documentclass[a4paper,10pt]{article}

\usepackage{color}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}


%% Encoding, font stuff
\usepackage[utf8x]{inputenc}
\usepackage{autofe}
\usepackage{ucs}
\usepackage[greek,english]{babel}
\usepackage{bbm}
\usepackage{bbding}

%% Symbols and whatever
\usepackage{amsmath,amsthm,amssymb,amsfonts,stmaryrd}

% Format file based on agda.fmt as included in lhs2TeX distribution.

%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%
%
\ReadOnlyOnce{note.fmt}%


\providecommand\mathbbm{\mathbb}

% Path composition from The Book.
\newcommand{\ct}{%
  \mathchoice{\mathbin{\raisebox{0.5ex}{$\displaystyle\centerdot$}}}%
             {\mathbin{\raisebox{0.5ex}{$\centerdot$}}}%
             {\mathbin{\raisebox{0.25ex}{$\scriptstyle\,\centerdot\,$}}}%
             {\mathbin{\raisebox{0.1ex}{$\scriptscriptstyle\,\centerdot\,$}}}
}

\DeclareUnicodeCharacter{737}{\textsuperscript{l}}
\DeclareUnicodeCharacter{8718}{\ensuremath{\blacksquare}}
\DeclareUnicodeCharacter{8759}{::}
\DeclareUnicodeCharacter{9669}{\ensuremath{\triangleleft}}
\DeclareUnicodeCharacter{9665}{\ensuremath{\triangleleft}}
\DeclareUnicodeCharacter{8799}{\ensuremath{\stackrel{\scriptscriptstyle ?}{=}}}
\DeclareUnicodeCharacter{10214}{\ensuremath{\llbracket}}
\DeclareUnicodeCharacter{10215}{\ensuremath{\rrbracket}}
\DeclareUnicodeCharacter{946}{\ensuremath{\beta}}
\DeclareUnicodeCharacter{8729}{\ensuremath{\ct}}
\DeclareUnicodeCharacter{10218}{\ensuremath{ \{ }}
\DeclareUnicodeCharacter{10219}{\ensuremath{ \} }}
\DeclareUnicodeCharacter{8718}{\ensuremath{\blacksquare}}

% TODO: This is in general not a good idea.
\providecommand\textepsilon{$\epsilon$}
\providecommand\textmu{$\mu$}
\providecommand\textbeta{$\beta$}
\providecommand\texttheta{$\theta$}


%Actually, varsyms should not occur in Agda output.

\renewcommand\Varid[1]{\mathord{\textsf{#1}}}
\let\Conid\Varid
\newcommand\Keyword[1]{\textsf{\textbf{#1}}}
\EndFmtInput



%% Layout stuff and other related goodies.
\usepackage[parfill]{parskip}
\usepackage{xspace}
\usepackage{todonotes}


%% URLs and other link stuff
\usepackage{url}
\usepackage{hyperref}
\usepackage[noabbrev]{cleveref}

\hypersetup{
  colorlinks,
  citecolor=DarkBlue,
  linkcolor=black,
  urlcolor=DarkBlue}

% Bibliography stuff
\usepackage[autostyle]{csquotes}

%% Commands
\newcommand{\todoi}[1]{\todo[inline]{#1}}
\newcommand{\withoutk}{\xspace\text{\tt \char45{}\char45{}without\char45{}K}\xspace}
\newcommand{\uip}{uniqueness of identity proofs\xspace}
\newcommand{\Uip}{Uniqueness of identity proofs\xspace}
\newcommand{\hott}{homotopy type theory\xspace}
\newcommand{\Hott}{Homotopy type theory\xspace}
\newcommand{\mltt}{Martin-L\"of's type theory\xspace}
\newcommand{\hit}{higher inductive type\xspace}
\newcommand{\Hit}{Higher inductive type\xspace}
\newcommand{\hits}{higher inductive types\xspace}
\newcommand{\Hits}{Higher inductive types\xspace}
\newcommand{\oit}{ordinary inductive type\xspace}
\newcommand{\Oit}{Ordinary inductive type\xspace}
\newcommand{\oits}{ordinary inductive types\xspace}
\newcommand{\Oits}{Ordinary inductive types\xspace}
\newcommand{\zeroconstructor}{$0$-constructor\xspace}
\newcommand{\zeroconstructors}{$0$-constructors\xspace}
\newcommand{\onehit}{$1$-HIT\xspace}
\newcommand{\onehits}{$1$-HITs\xspace}
\newcommand{\oneconstructor}{$1$-constructor\xspace}
\newcommand{\oneconstructors}{$1$-constructors\xspace}
\newcommand{\twohit}{$2$-HIT\xspace}
\newcommand{\twohits}{$2$-HITs\xspace}
\newcommand{\twoconstructor}{$2$-constructor\xspace}
\newcommand{\twoconstructors}{$2$-constructors\xspace}
\newcommand{\zerovariable}{$0$-variable\xspace}
\newcommand{\onevariable}{$1$-variable\xspace}
\newcommand{\twovariable}{$2$-variable\xspace}
\newcommand{\zerovariables}{$0$-variables\xspace}
\newcommand{\onevariables}{$1$-variables\xspace}
\newcommand{\twovariables}{$2$-variables\xspace}
\newcommand{\ie}{i.e.\xspace}
\newcommand{\eg}{e.g.\xspace}
\newcommand{\Type}{\mbox{Type}}
\newcommand{\wtypes}{$W$-types\xspace}
\newcommand{\wtype}{$W$-type\xspace}
\newcommand{\ronehit}{restricted \onehit\xspace}
\newcommand{\ronehits}{restricted \onehits\xspace}
\newcommand{\Ronehit}{Restricted \onehit\xspace}
\newcommand{\Ronehits}{Restricted \onehits\xspace}

\title{Notes on \onehits}

\author{Gabe Dijkstra}

\date{}

\begin{document}

\maketitle

\section{Introduction}

\section{Describing \hits}

If we define an ordinary inductive type, we start out by writing down
a list of constructors, \eg:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Keyword{data}\;\Conid{T}\;\mathbin{:}\;\Conid{Type}\;\Keyword{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{c0}\;{}\<[9]%
\>[9]{}\mathbin{:}\;\Conid{F0}\;\Conid{T}\;\to \;\Conid{T}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{c1}\;{}\<[9]%
\>[9]{}\mathbin{:}\;\Conid{F1}\;\Conid{T}\;\to \;\Conid{T}\;{}\<[E]%
\\
\>[9]{}\vdots{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{ck}\;{}\<[9]%
\>[9]{}\mathbin{:}\;\Conid{Fk}\;\Conid{T}\;\to \;\Conid{T}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

where all \ensuremath{\Conid{Fi}\;\mathbin{:}\;\Conid{Type}\;\to \;\Conid{Type}} are strictly positive
functors. Equivalently, we can define an inductive type with a single
constructor:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Keyword{data}\;\Conid{T}\;\mathbin{:}\;\Conid{Type}\;\Keyword{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{c}\;\mathbin{:}\;\Conid{F}\;\Conid{T}\;\to \;\Conid{T}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

where \ensuremath{\Conid{F}\;\Conid{X}\;:\equiv\;\Conid{F0}\;\Conid{X}\;\Varid{+}\;\Conid{F1}\;\Conid{X}\;\Varid{+}\;\Varid{hdots}\;\Varid{+}\;\Conid{Fk}\;\Conid{X}}, so a single strictly
positive functor is all we need to describe an \oit.

In the case of \hits, the situation is more involved. Consider for
example the circle data type:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Keyword{data}\;\Conid{S1}\;\mathbin{:}\;\Conid{Type}\;\Keyword{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{base}\;\mathbin{:}\;\Conid{S1}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{loop}\;\mathbin{:}\;\Varid{base}\;=\;\Varid{base}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

There are two things that are different from our previous
situation. Firstly, the result type of \ensuremath{\Varid{loop}} is not \ensuremath{\Conid{S1}}, but a path
space of \ensuremath{\Conid{S1}}: constructors are no longer algebras of functor, but a
kind of \emph{dialgebra}: the arguments as well as the result type of
a constructor may vary. Secondly, the \ensuremath{\Varid{loop}} constructor refers to the
previous constructor \ensuremath{\Varid{base}}.

The result type of a constructor can also depend on the value of its
arguments, as we see in the definition of propositional truncation as
a \hit:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Keyword{data}\;\mathbin{//}\;\Conid{A}\;\mathbin{//}\;\mathbin{:}\;\Conid{Type}\;\Keyword{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}[\mskip1.5mu \anonymous \mskip1.5mu]\;\mathbin{:}\;\Conid{A}\;\to \;\mathbin{//}\;\Conid{A}\;\mathbin{//}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{trunc}\;\mathbin{:}\;(\Varid{x}\;\Varid{y}\;\mathbin{:}\;\mathbin{//}\;\Conid{A}\;\mathbin{//})\;\to \;\Varid{x}\;=\;\Varid{y}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Constructors of a \hit are \emph{dependent dialgebras}. In general, a
higher inductive type looks as follows:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{37}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Keyword{data}\;\Conid{T}\;\mathbin{:}\;\Conid{Type}\;\Keyword{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{c0}\;{}\<[11]%
\>[11]{}\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F0}\;\Conid{T})\;{}\<[37]%
\>[37]{}\to \;\Conid{G0}\;\Conid{T}\;\Varid{x}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{c1}\;{}\<[11]%
\>[11]{}\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F1}\;\Conid{T}\;\Varid{c0})\;{}\<[37]%
\>[37]{}\to \;\Conid{G1}\;\Conid{T}\;\Varid{c0}\;\Varid{x}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{c2}\;{}\<[11]%
\>[11]{}\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F2}\;\Conid{T}\;\Varid{c0}\;\Varid{c1})\;{}\<[37]%
\>[37]{}\to \;\Conid{G2}\;\Conid{T}\;\Varid{c0}\;\Varid{c1}\;\Varid{x}\;{}\<[E]%
\\
\>[11]{}\vdots{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{ck+1}\;{}\<[11]%
\>[11]{}\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{Fk}\;\Conid{T}\;\Varid{c0}\;\Varid{hdots}\;\Varid{ck})\;{}\<[37]%
\>[37]{}\to \;\Conid{Gk}\;\Conid{T}\;\Varid{c0}\;\Varid{hdots}\;\Varid{ck}\;\Varid{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We will refer to the \ensuremath{\Conid{Fi}} functors as \emph{argument} functors and the
\ensuremath{\Conid{Gi}} functors as \emph{target} functors. The types of the argument
functors are:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{F0}\;{}\<[6]%
\>[6]{}\mathbin{:}\;\Conid{Type}\;{}\<[22]%
\>[22]{}\to \;\Conid{Type}{}\<[E]%
\\
\>[B]{}\Conid{F1}\;{}\<[6]%
\>[6]{}\mathbin{:}\;(\Conid{F0},\Conid{G0})\;\Varid{-alg}\;{}\<[22]%
\>[22]{}\to \;\Conid{Type}{}\<[E]%
\\
\>[B]{}\Conid{F2}\;{}\<[6]%
\>[6]{}\mathbin{:}\;(\Conid{F1},\Conid{G1})\;\Varid{-alg}\;{}\<[22]%
\>[22]{}\to \;\Conid{Type}{}\<[E]%
\\
\>[B]{}\Conid{Fk+1}\;\mathbin{:}\;(\Conid{Fk},\Conid{Gk})\;\Varid{-alg}\;{}\<[22]%
\>[22]{}\to \;\Conid{Type}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

where \ensuremath{(\Conid{F0},\Conid{G0})\;\Varid{-alg})} is the category whose objects are dependent
dialgebras \ensuremath{(\Conid{X}\;\mathbin{:}\;\Conid{Type})\;\Varid{×}\;(\Varid{θ}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F0}\;\Conid{X})\;\to \;\Conid{G0}\;\Conid{X}\;\Varid{x})}. The category
\ensuremath{(\Conid{F}\;(\Varid{i+1}),\Conid{G}\;(\Varid{i+1})\;\Varid{-alg}}has as objects: \ensuremath{(\Conid{X}\;\mathbin{:}\;(\Conid{Fi},\Conid{Gi})\;\Varid{-alg})\;\Varid{×}\;(\Varid{θ}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F}\;(\Varid{i+1})\;\Conid{X})\;\to \;\Conid{G}\;(\Varid{i+1})\;\Conid{X}\;\Varid{x})}. The target functors also take the value of
the arguments as an argument, so they have the following types:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{27}{@{}>{\hspre}l<{\hspost}@{}}%
\column{35}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{G0}\;{}\<[7]%
\>[7]{}\mathbin{:}\;\int\;\Conid{Type}\;{}\<[27]%
\>[27]{}\Conid{F0}\;{}\<[35]%
\>[35]{}\to \;\Conid{Type}{}\<[E]%
\\
\>[B]{}\Conid{G1}\;{}\<[7]%
\>[7]{}\mathbin{:}\;\int\;(\Conid{F0},\Conid{G0})\;\Varid{-alg}\;{}\<[27]%
\>[27]{}\Conid{F1}\;{}\<[35]%
\>[35]{}\to \;\Conid{Type}{}\<[E]%
\\
\>[B]{}\Conid{G2}\;{}\<[7]%
\>[7]{}\mathbin{:}\;\int\;(\Conid{F1},\Conid{G1})\;\Varid{-alg}\;{}\<[27]%
\>[27]{}\Conid{F2}\;{}\<[35]%
\>[35]{}\to \;\Conid{Type}{}\<[E]%
\\
\>[B]{}\Conid{Gk+1}\;{}\<[7]%
\>[7]{}\mathbin{:}\;\int\;(\Conid{Fk},\Conid{Gk})\;\Varid{-alg}\;{}\<[27]%
\>[27]{}\Conid{F}\;(\Varid{k+1})\;{}\<[35]%
\>[35]{}\to \;\Conid{Type}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We see that the general shape of a constructor is a dependent dialgebra:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{c}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F}\;\Conid{X})\;\to \;\Conid{G}\;(\Conid{X},\Varid{x}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

where \ensuremath{\Conid{C}\;\mathbin{:}\;\Conid{Cat}}, \ensuremath{\Conid{F}\;\mathbin{:}\;\Conid{C}\;\to \;\Conid{Type}} and \ensuremath{\Conid{G}\;\mathbin{:}\;\int\;\Conid{C}\;\Conid{F}\;\to \;\Conid{Type}}, where \ensuremath{\Conid{C}}
is \ensuremath{\Conid{Type}} or some category of dependent dialgebras.

When describing \hits, we do not allow for any target functor \ensuremath{\Conid{G}}: it
must either return the type we are defining or a (possibly iterated)
path space of that type.

A \emph{\zeroconstructor} or \emph{point constructor} is a dialgebra:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{c}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F}\;\Conid{X})\;\to \;\Conid{U}\;\Conid{X}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

where \ensuremath{\Conid{C}\;\mathbin{:}\;\Conid{Cat}}, \ensuremath{\Conid{F}\;\mathbin{:}\;\Conid{C}\;\to \;\Conid{Type}} and \ensuremath{\Conid{U}\;\mathbin{:}\;\Conid{C}\;\to \;\Conid{Type}} its forgetful
functor.

A \emph{\oneconstructor} is a dependent dialgebra of which the target
functor returns a path space:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{c}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F}\;\Conid{X})\;\to \;\Conid{Eq0}\;\Conid{X}\;\Varid{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

where \ensuremath{\Conid{C}\;\mathbin{:}\;\Conid{Cat}}, \ensuremath{\Conid{F},\Conid{U}\;\mathbin{:}\;\Conid{C}\;\to \;\Conid{Type}}, and \ensuremath{\Conid{Eq0}\;\mathbin{:}\;\int\;\Conid{C}\;\Conid{F}\;\to \;\Conid{Type}} is the functor:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Conid{Eq0}\;(\Conid{X},\Varid{x})\;:\equiv\;(\Varid{l0}\;\Conid{X}\;\Varid{x}\;=\;\Varid{r0}\;\Conid{X}\;\Varid{x}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

where \ensuremath{\Varid{l0},\Varid{r0}\;\mathbin{:}\;\Conid{F}\;\to \;\Conid{U}} are natural transformations.

For higher path constructors, we have to specify a tower of natural
transformations, specifying the end points at every level. To specify
an \ensuremath{(\Varid{n+1})}-constructor, we need to give the natural transformations:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{l0},\Varid{r0}\;{}\<[11]%
\>[11]{}\mathbin{:}\;\Conid{F}\;\to \;\Conid{U}{}\<[E]%
\\
\>[3]{}\Varid{l1},\Varid{r1}\;{}\<[11]%
\>[11]{}\mathbin{:}\;\Varid{1}\;\to \;\Conid{Eq0}{}\<[E]%
\\
\>[3]{}\Varid{l2},\Varid{r2}\;{}\<[11]%
\>[11]{}\mathbin{:}\;\Varid{1}\;\to \;\Conid{Eq1}\;{}\<[E]%
\\
\>[11]{}\vdots{}\<[E]%
\\
\>[3]{}\Varid{ln},\Varid{rn}\;{}\<[11]%
\>[11]{}\mathbin{:}\;\Varid{1}\;\to \;\Conid{Eqn-1}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

where \ensuremath{\Conid{Eqi}\;\Conid{X}\;\Varid{x}\;:\equiv\;(\Varid{li}\;\Conid{X}\;\Varid{x}\;=\;\Varid{ri}\;\Conid{X}\;\Varid{x})}. \ensuremath{\Conid{Eqn}} is then the target
functor we are interested in.

\subsection{Strict positivity}

Apart from the restrictions on targets, we also want all functors
involved to be strictly positive. In the case of \oits, we also have
this restriction. An example of an inductive type which constructor is
not strictly positive is the following:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Keyword{data}\;\Conid{Term}\;\mathbin{:}\;\Conid{Type}\;\Keyword{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{lam}\;\mathbin{:}\;(\Conid{Term}\;\to \;\Conid{Term})\;\to \;\Conid{Term}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Using the type \ensuremath{\Conid{Term}}, we can find inhabitants of the empty type. We
therefore only consider inductive types defined by strictly positive
functors, \ie containers. Containers however only describe functors
\ensuremath{\Conid{Type}\;\to \;\Conid{Type}}. An example of that shows that we need a notion of
strict positivity for any functor into \ensuremath{\Conid{Type}} is that of the ``initial
field''. If we write down the axioms of an algebraic structure as
constructors, the inductive type we get is then the initial object in
the category of that algebraic structure, \ie  we can define a type \ensuremath{\Conid{T}}
with the monoid axioms as constructors:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Keyword{data}\;\Conid{T}\;\mathbin{:}\;\Conid{Type}\;\Keyword{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{uip}\;\mathbin{:}\;(\Varid{x}\;\Varid{y}\;\mathbin{:}\;\Conid{T})\;(\Varid{p}\;\Varid{q}\;\mathbin{:}\;\Varid{x}\;=\;\Varid{y})\;\to \;\Varid{p}\;=\;\Varid{q}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{\char95 ∙\char95 }\;\mathbin{:}\;\Conid{T}\;\to \;\Conid{T}\;\to \;\Conid{T}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{assoc}\;\mathbin{:}\;(\Varid{x}\;\Varid{y}\;\Varid{z}\;\mathbin{:}\;\Conid{T})\;\to \;(\Varid{x}\;\Varid{∙}\;\Varid{y})\;\Varid{∙}\;\Varid{z}\;=\;\Varid{x}\;\Varid{∙}\;(\Varid{y}\;\Varid{∙}\;\Varid{z}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{e}\;\mathbin{:}\;\Conid{T}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{e-unit-l}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{T})\;\to \;\Varid{e}\;\Varid{∙}\;\Varid{x}\;=\;\Varid{x}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{e-unit-r}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{T})\;\to \;\Varid{x}\;\Varid{∙}\;\Varid{e}\;=\;\Varid{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\ensuremath{\Conid{T}} is equivalent to the unit type, which is the initial object in the
category of monoids. If we now were to write down the axioms of a
field, we run into trouble: there is no initial object in the category
of fields. The culprit is the inverse operation, which has the type:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{inv}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{T})\;\to \;(\Varid{x}\;=\;\Varid{0}\;\to \;\Varid{⊥})\;\to \;\Conid{T}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The constructor \ensuremath{\Varid{0}} occurs negatively in this constructor.

To generalise the notion of strict positivity, we can generalise the
notion of containers to not only describe functors \ensuremath{\Conid{Type}\;\to \;\Conid{Type}}, but
functors \emph{into} \ensuremath{\Conid{Type}} from any \ensuremath{\Conid{C}\;\mathbin{:}\;\Conid{Cat}}. A \emph{generalised
  container} is given by:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Conid{S}\;\mathbin{:}\;\Conid{Type}{}\<[E]%
\\
\>[3]{}\Conid{P}\;\mathbin{:}\;\Conid{S}\;\to \;\mathbin{/}\;\Conid{C}\;\mathbin{/}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Its extension is then defined as:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{⟦}\;\Conid{S}\;\Varid{◁}\;\Conid{P}\;\Varid{⟧}\;\mathbin{:}\;\Conid{C}\;\to \;\Conid{Type}{}\<[E]%
\\
\>[3]{}\Varid{⟦}\;\Conid{S}\;\Varid{◁}\;\Conid{P}\;\Varid{⟧}\;\Conid{X}\;:\equiv\;(\Varid{s}\;\mathbin{:}\;\Conid{S})\;\Varid{×}\;\Conid{C}\;(\Conid{P}\;\Varid{s},\Conid{X}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

with the action on morphisms defined as:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{⟦}\;\Conid{F}\;\Varid{⟧}\;\mathbin{:}\;\Conid{C}\;(\Conid{X},\Conid{Y})\;\to \;\Varid{⟦}\;\Conid{F}\;\Varid{⟧}\;\Conid{X}\;\to \;\Varid{⟦}\;\Conid{F}\;\Varid{⟧}\;\Conid{Y}{}\<[E]%
\\
\>[3]{}\Varid{⟦}\;\Conid{F}\;\Varid{⟧}\;\Varid{f}\;(\Varid{s},\Varid{t})\;:\equiv\;(\Varid{s},\Varid{f}\;\Varid{∘}\;\Varid{t}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks


\subsection{\Hits as a sequence of monads}


\section{\Ronehits}

\todoi{coherence and other reasons why things are difficult}

\section{Algebras}

The type of \emph{\ensuremath{\Conid{F}}-algebras}, or simply \emph{algebras}, can be
defined as follows:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Conid{Alg}\;:\equiv\;(\Conid{X}\;\mathbin{:}\;\Conid{Type})\;\Varid{×}\;(\Varid{θ}\;\mathbin{:}\;\Conid{F}\;\Conid{X}\;\to \;\Conid{X}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

where the type morphisms is defined as follows:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Conid{Alg-hom}\;\mathbin{:}\;\Conid{Alg}\;\to \;\Conid{Alg}\;\to \;\Conid{Type}{}\<[E]%
\\
\>[3]{}\Conid{Alg-hom}\;(\Conid{X},\Varid{θ})\;(\Conid{Y},\Varid{ρ})\;:\equiv\;{}\<[E]%
\\
\>[3]{}\hsindent{5}{}\<[8]%
\>[8]{}(\Varid{f}\;\mathbin{:}\;\Conid{X}\;\to \;\Conid{Y})\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{×}\;{}\<[8]%
\>[8]{}(\Varid{f-β₀}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F}\;\Conid{X})\;\to \;\Varid{f}\;(\Varid{θ}\;\Varid{x})\;=\;\Varid{ρ}\;(\Conid{F}\;\Varid{f}\;\Varid{x})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The witness of commutativity has suggestively been named \ensuremath{\Varid{f-β₀}} as
this gives us the \ensuremath{\Varid{β}}-rule for the recursion and induction principles.

\todoi{Something about having \ensuremath{\Varid{f₀}\;\mathbin{:}\;\Varid{f}\;\Varid{∘}\;\Varid{θ}\;\equiv\;\Varid{ρ}\;\Varid{∘}\;\Conid{F}\;\Varid{f}} instead. We need
  function extensionality either way, but this way it makes the
  arguments later on a bit easier. Also, the dependent versions don't
  work as pointfree as these ones}

\subsection{Homotopy initial algebras}

We call an algebra \ensuremath{(\Conid{X},\Varid{θ})} \emph{homotopy initial} if it has the
property that for every algebra \ensuremath{(\Conid{Y},\Varid{ρ})}, \ensuremath{\Conid{Alg-hom}\;(\Conid{X},\Varid{θ})\;(\Conid{Y},\Varid{ρ})}
is contractible, \ie:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{is-initial}\;\mathbin{:}\;\Conid{Alg}\;\to \;\Conid{Type}{}\<[E]%
\\
\>[3]{}\Varid{is-initial}\;\Varid{θ}\;{}\<[17]%
\>[17]{}:\equiv\;{}\<[21]%
\>[21]{}(\Varid{ρ}\;\mathbin{:}\;\Conid{Alg})\;\Varid{→}\;\Varid{is-contr}\;(\Conid{Alg-hom}\;\Varid{θ}\;\Varid{ρ})\;{}\<[E]%
\\
\>[17]{}\equiv\;{}\<[21]%
\>[21]{}(\Varid{ρ}\;\mathbin{:}\;\Conid{Alg})\;\Varid{→}\;(\Varid{f}\;\mathbin{:}\;\Conid{Alg-hom}\;\Varid{θ}\;\Varid{ρ})\;\Varid{×}\;((\Varid{g}\;\mathbin{:}\;\Conid{Alg-hom}\;\Varid{θ}\;\Varid{ρ})\;\Varid{→}\;\Varid{f}\;=\;\Varid{g}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsubsection{Equality of algebra morphisms}

As we see in the definition of homotopy initiality, we need to be able
to talk about equality of algebra morphisms. Given algebras \ensuremath{(\Conid{X},\Varid{θ})}
and \ensuremath{(\Conid{Y},\Varid{ρ})} and morphisms \ensuremath{(\Varid{f},\Varid{f-β₀})} and \ensuremath{(\Varid{g},\Varid{g-β₀})} between
them, we know that, by equality on Σ-types, the following holds:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[4]{}(\Varid{f},\Varid{f-β₀})\;=\;(\Varid{g},\Varid{g-β₀}){}\<[E]%
\\
\>[B]{}\Varid{≃}\;{}\<[4]%
\>[4]{}(\Varid{p}\;\mathbin{:}\;\Varid{f}\;=\;\Varid{g}){}\<[E]%
\\
\>[B]{}\Varid{×}\;{}\<[4]%
\>[4]{}(\Varid{p-β₀}\;\mathbin{:}\;\Varid{transport}\;(\Varid{λ}\;\Varid{h}\;\mathbin{\circ}\;(\Varid{x}\;\mathbin{:}\;\Conid{F}\;\Conid{X})\;\Varid{→}\;\Varid{h}\;(\Varid{θ}\;\Varid{x})\;=\;\Varid{ρ}\;(\Conid{F}\;\Varid{h}\;\Varid{x}))\;\Varid{f-β₀}\;=\;\Varid{g-β₀}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We not only need to show that the functions \ensuremath{\Varid{f}} and \ensuremath{\Varid{g}} are equal, but
also that their β-laws are in some sense compatible with eachother,
respecting the equality \ensuremath{\Varid{f}\;=\;\Varid{g}}.

As it turns out, the above is equivalent to something which is more
convenient in subsequent proofs:


\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[4]{}\Varid{transport}\;(\Varid{λ}\;\Varid{h}\;\Varid{→}\;(\Varid{x}\;\mathbin{:}\;\Conid{F}\;\Conid{X})\;\Varid{→}\;\Varid{h}\;(\Varid{θ}\;\Varid{x})\;=\;\Varid{ρ}\;(\Conid{F}\;\Varid{h}\;\Varid{x}))\;\Varid{p}\;\Varid{f-β₀}\;=\;\Varid{g-β₀}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{≃}\;\{\mskip1.5mu \Varid{transport}\;\Varid{over}\;\Conid{Π-types}\mskip1.5mu\}\;{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}(\Varid{λ}\;\Varid{x}\;\Varid{→}\;\Varid{transport}\;(\Varid{λ}\;\Varid{h}\;\Varid{→}\;\Varid{h}\;(\Varid{θ}\;\Varid{x})\;=\;\Varid{ρ}\;(\Conid{F}\;\Varid{h}\;\Varid{x}))\;\Varid{p}\;(\Varid{f-β₀}\;\Varid{x}))\;=\;\Varid{g-β₀}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{≃}\;\{\mskip1.5mu \Varid{function}\;\Varid{extensionality}\mskip1.5mu\}\;{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}((\Varid{x}\;\mathbin{:}\;\Conid{A})\;\Varid{→}\;\Varid{transport}\;(\Varid{λ}\;\Varid{h}\;\Varid{→}\;\Varid{h}\;(\Varid{θ}\;\Varid{x})\;=\;\Varid{ρ}\;(\Conid{F}\;\Varid{h}\;\Varid{x}))\;\Varid{p}\;(\Varid{f-β₀}\;\Varid{x})\;=\;\Varid{g-β₀}\;\Varid{x}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{≃}\;\{\mskip1.5mu \Varid{transporting}\;\Varid{over}\;\Varid{equalities}\mskip1.5mu\}\;{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\mathbin{!}\;(\Varid{ap}\;(\Varid{λ}\;\Varid{h}\;\Varid{→}\;\Varid{h}\;(\Varid{θ}\;\Varid{x}))\;\Varid{p})\;\Varid{∙}\;\Varid{f-β₀}\;\Varid{x}\;\Varid{∙}\;\Varid{ap}\;(\Varid{λ}\;\Varid{h}\;\Varid{→}\;\Varid{ρ}\;(\Conid{F}\;\Varid{h}\;\Varid{x}))\;\Varid{p}\;=\;\Varid{g-β₀}\;\Varid{x}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{≃}\;\{\mskip1.5mu \Varid{path}\;\Varid{algebra}\mskip1.5mu\}\;{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{f-β₀}\;\Varid{x}\;\Varid{∙}\;\Varid{ap}\;(\Varid{λ}\;\Varid{h}\;\Varid{→}\;\Varid{ρ}\;(\Conid{F}\;\Varid{h}\;\Varid{x}))\;\Varid{p}\;=\;\Varid{ap}\;(\Varid{λ}\;\Varid{h}\;\Varid{→}\;\Varid{h}\;(\Varid{θ}\;\Varid{x}))\;\Varid{p}\;\Varid{∙}\;\Varid{g-β₀}\;\Varid{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The last equation tells us that showing that two algebra morphisms are
equal is somewhat like giving an algebra morphism from the witness of
the β-law for \ensuremath{\Varid{f}} to that of \ensuremath{\Varid{g}}, as we can see if we draw the
corresponding diagram:

\todoi{comm diag}

\subsection{Algebras for \ronehit descriptions}

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Conid{Alg}\;:\equiv\;{}\<[E]%
\\
\>[3]{}\hsindent{5}{}\<[8]%
\>[8]{}(\Conid{X}\;\mathbin{:}\;\Conid{Type})\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{×}\;{}\<[8]%
\>[8]{}(\Varid{θ₀}\;\mathbin{:}\;\Conid{F₀}\;\Conid{X}\;\to \;\Conid{X})\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{×}\;{}\<[8]%
\>[8]{}(\Varid{θ₁}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F₁}\;\Conid{X})\;\to \;\Varid{l}\;(\Varid{θ₀}\;\Varid{*}\;\Varid{x})\;=\;\Varid{r}\;(\Varid{θ₀}\;\Varid{*}\;\Varid{x})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\ensuremath{\Varid{θ₀}} is an \ensuremath{\Conid{F₀}}-algebra and \ensuremath{\Varid{θ₁}} can be seen as a dependent dialgebra
by defining the functor \ensuremath{\Conid{G₁}}:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Conid{G₁}\;\mathbin{:}\;\Varid{∫}\;\Conid{F₀-Algebra}\;\Conid{F₁}\;\to \;\Conid{Type}{}\<[E]%
\\
\>[3]{}\Conid{G₁}\;((\Conid{X},\Varid{θ}),\Varid{x})\;:\equiv\;(\Varid{l}\;(\Varid{θ₀}\;\Varid{*}\;\Varid{x})\;=\;\Varid{r}\;(\Varid{θ₀}\;\Varid{*}\;\Varid{x})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Its hom-types can be defined as follows:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{36}{@{}>{\hspre}l<{\hspost}@{}}%
\column{42}{@{}>{\hspre}l<{\hspost}@{}}%
\column{50}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Conid{Alg-hom}\;\mathbin{:}\;\Conid{Alg}\;\to \;\Conid{Alg}\;\to \;\Conid{Type}{}\<[E]%
\\
\>[3]{}\Conid{Alg-hom}\;(\Conid{X},\Varid{θ})\;(\Conid{Y},\Varid{ρ})\;:\equiv\;{}\<[E]%
\\
\>[3]{}\hsindent{5}{}\<[8]%
\>[8]{}(\Varid{f}\;\mathbin{:}\;\Conid{X}\;\to \;\Conid{Y})\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{×}\;{}\<[8]%
\>[8]{}(\Varid{f-β₀}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F₀}\;\Conid{X})\;\to \;{}\<[36]%
\>[36]{}\Varid{f}\;{}\<[42]%
\>[42]{}(\Varid{θ₀}\;\Varid{x})\;{}\<[50]%
\>[50]{}=\;\Varid{ρ₀}\;(\Conid{F₀}\;\Varid{f}\;\Varid{x}))\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{×}\;{}\<[8]%
\>[8]{}(\Varid{f-β₁}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F₁}\;\Conid{X})\;\to \;\Conid{G₁}\;\Varid{x}\;{}\<[36]%
\>[36]{}\Varid{f},\Varid{f₀}\;{}\<[42]%
\>[42]{}(\Varid{θ₁}\;\Varid{x})\;{}\<[50]%
\>[50]{}=\;\Varid{ρ₁}\;(\Conid{F₁}\;\Varid{f}\;\Varid{x})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks


\section{Induction}

Given a functor \ensuremath{\Conid{F}\;\mathbin{:}\;\Conid{Type}\;\to \;\Conid{Type}} given as a container \ensuremath{\Conid{F}\;:\equiv\;\Conid{S}\;\Varid{◁}\;\Conid{P}}, the \wtype \ensuremath{\Conid{W}} is defined as having the following
introduction rule / constructor:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{c}\;\mathbin{:}\;\Conid{F}\;\Conid{W}\;\to \;\Conid{W}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

as well as an elimination rule / induction principle:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{ind}\;\mathbin{:}\;{}\<[E]%
\\
\>[3]{}\hsindent{5}{}\<[8]%
\>[8]{}(\Conid{B}\;\mathbin{:}\;\Conid{W}\;\to \;\Conid{Type})\;{}\<[E]%
\\
\>[3]{}\hsindent{5}{}\<[8]%
\>[8]{}(\Varid{m}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F}\;\Conid{W})\;\Varid{→}\;\Varid{□}\;\Conid{F}\;\Conid{B}\;\Varid{x}\;\Varid{→}\;\Conid{B}\;(\Varid{c}\;\Varid{x}))\;{}\<[E]%
\\
\>[3]{}\hsindent{5}{}\<[8]%
\>[8]{}(\Varid{x}\;\mathbin{:}\;\Conid{W})\;{}\<[E]%
\\
\>[3]{}\hsindent{1}{}\<[4]%
\>[4]{}\to \;{}\<[8]%
\>[8]{}\Conid{B}\;\Varid{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

with computation rule:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{ind-β₀}\;\mathbin{:}\;{}\<[E]%
\\
\>[3]{}\hsindent{5}{}\<[8]%
\>[8]{}(\Conid{B}\;\mathbin{:}\;\Conid{W}\;\to \;\Conid{Type})\;{}\<[E]%
\\
\>[3]{}\hsindent{5}{}\<[8]%
\>[8]{}(\Varid{m}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F}\;\Conid{W})\;\Varid{→}\;\Varid{□}\;\Conid{F}\;\Conid{B}\;\Varid{x}\;\Varid{→}\;\Conid{B}\;(\Varid{c}\;\Varid{x}))\;{}\<[E]%
\\
\>[3]{}\hsindent{5}{}\<[8]%
\>[8]{}(\Varid{x}\;\mathbin{:}\;\Conid{F}\;\Conid{W})\;{}\<[E]%
\\
\>[3]{}\hsindent{1}{}\<[4]%
\>[4]{}\to \;{}\<[8]%
\>[8]{}\Varid{ind}\;\Conid{B}\;\Varid{m}\;(\Varid{c}\;\Varid{x})\;=\;\Varid{m}\;\Varid{x}\;(\Varid{□-lift}\;\Conid{F}\;(\Varid{ind}\;\Conid{B}\;\Varid{m})\;\Varid{x}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection{Initiality implies induction}

The induction principle tells us that for a family \ensuremath{\Conid{B}\;\mathbin{:}\;\Conid{W}\;\to \;\Conid{Type}} and
a motive \ensuremath{\Varid{m}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F}\;\Conid{W})\;\Varid{→}\;\Varid{□}\;\Conid{F}\;\Conid{B}\;\Varid{x}\;\Varid{→}\;\Conid{B}\;(\Varid{c}\;\Varid{x})}, we get a dependent
function \ensuremath{\Varid{ind}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{W})\;\to \;\Conid{B}\;\Varid{x}} along with a computation rule.

Note that \ensuremath{\Varid{m}}, along with \ensuremath{\Varid{c}}, can be seen as a morphism between the
families \ensuremath{(\Conid{W},\Conid{B})} and \ensuremath{(\Conid{F}\;\Conid{W},\Varid{□}\;\Conid{F}\;\Conid{B})}.

Another way to say this is that given a function \ensuremath{\Varid{p}\;\mathbin{:}\;\Conid{B}\;\to \;\Conid{W}} for some
\ensuremath{\Conid{B}\;\mathbin{:}\;\Conid{Type}} and that we want \ensuremath{\Varid{θ}\;\mathbin{:}\;\Conid{F}\;\Conid{B}\;\to \;\Conid{B}} such that \ensuremath{\Varid{θ}}, along with
\ensuremath{\Varid{c}}, becomes a morphism \ensuremath{\Conid{Fp}\;\to \;\Varid{p}} in the arrow category. This is
equivalent to asking for an algebra \ensuremath{(\Conid{B},\Varid{θ})} along with an algebra
morphism \ensuremath{(\Conid{B},\Varid{θ})\;\to \;(\Conid{W},\Varid{c})}.

\todoi{Give arguments why section induction is correct}

\todoi{Show that initiality implies section induction}

\subsection{Induction principle for \ronehits}

To get the induction principle of \ronehits, we need to take that of
the ordinary \wtypes and extend it with the new (path) constructor: we
have to add a method to \ensuremath{\Varid{ind}} and the appropriate computation rule for
that.

Consider the method for the \zeroconstructor:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{m₀}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F₀}\;\Conid{X})\;\to \;\Varid{□}\;\Conid{F₀}\;\Conid{B}\;\Varid{x}\;\to \;\Conid{B}\;(\Varid{c₀}\;\Varid{x}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We can read this as showing that if for all subterms of \ensuremath{\Varid{c₀}\;\Varid{x}} \ensuremath{\Conid{B}}
holds, \ensuremath{\Conid{B}} also holds for \ensuremath{\Varid{c₀}\;\Varid{x}} itself. Since we are dealing with a
\zeroconstructor, we don't have any issues with the target of the
constructor: the target functor is the identity functor. For the
motive of the \oneconstructor, we want something like:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{m₁}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F₁}\;\Conid{X})\;\to \;\Varid{□}\;\Conid{F₁}\;\Conid{B}\;\Varid{x}\;\to \;\Varid{□}\;\Conid{G}\;(\Varid{c₁}\;\Varid{x}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We need to figure out what the lifting of \ensuremath{\Conid{B}} to the target functor
\ensuremath{\Conid{G}} is.

\section{Induction implies homotopy initiality}

We want to show that, given \ensuremath{\Conid{T}\;\mathbin{:}\;\Conid{Type}} and \ensuremath{\Varid{c}\;\mathbin{:}\;\Conid{F}\;\Conid{T}\;\to \;\Conid{T}} that
satisfies the induction principle, the algebra \ensuremath{(\Conid{T},\Varid{c})} is initial,
\ie for any algebra \ensuremath{(\Conid{X},\Varid{θ})}, \ensuremath{\Conid{Alg-hom}\;(\Conid{T},\Varid{c})\;(\Conid{X},\Varid{θ})\;\Varid{≃}\;\Varid{1}}. We will
first show that we have an algebra morphism \ensuremath{\Varid{f}\;\mathbin{:}\;(\Conid{T},\Varid{c})\;\to \;(\Conid{X},\Varid{θ})}
and will then show that this algebra morphism is unique.

\subsection{W-types}

\subsubsection{Existence}

We can use the induction principle to produce the algebra morphism we want:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{f}\;\mathbin{:}\;\Conid{T}\;\to \;\Conid{X}{}\<[E]%
\\
\>[3]{}\Varid{f}\;:\equiv\;\Varid{ind}\;(\Varid{λ}\;\Varid{x}\;\to \;\Conid{X})\;(\Varid{λ}\;(\Varid{s},\anonymous )\;\Varid{t}\;\to \;\Varid{θ}\;(\Varid{s},\Varid{t})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The computation rule is then given directly by the computation rule
for the induction rule:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{f₀}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F}\;\Conid{T})\;\to \;\Varid{f}\;(\Varid{θ}\;\Varid{x})\;=\;\Varid{θ}\;(\Conid{F}\;\Varid{f}\;\Varid{x}){}\<[E]%
\\
\>[3]{}\Varid{f₀}\;:\equiv\;\Varid{ind-β}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsubsection{Uniqueness}

Assuming that we have an algebra morphism \ensuremath{(\Varid{g},\Varid{g₀})\;\mathbin{:}\;(\Conid{T},\Varid{c})\;\to \;(\Conid{X},\Varid{θ})}, we need to show that \ensuremath{(\Varid{f},\Varid{f₀})\;=\;(\Varid{g},\Varid{g₀})}. Showing that the \ensuremath{\Varid{f}\;=\;\Varid{g}} can be done by induction, using the motive \ensuremath{\Varid{λ}\;\Varid{x}\;\to \;\Varid{f}\;\Varid{x}\;=\;\Varid{g}\;\Varid{x}}. The induction step is then proven as follows:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{step}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Varid{⟦}\;\Conid{F}\;\Varid{⟧₀}\;\Conid{T})\;\Varid{→}\;\Varid{□}\;\Conid{F}\;\Varid{f=g-B}\;\Varid{x}\;\Varid{→}\;\Varid{f=g-B}\;(\Varid{c}\;\Varid{x}){}\<[E]%
\\
\>[3]{}\Varid{step}\;\Varid{x}\;\Varid{u}\;:\equiv\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{f}\;(\Varid{c}\;\Varid{x})\;{}\<[E]%
\\
\>[5]{}\hsindent{1}{}\<[6]%
\>[6]{}\Varid{=⟪}\;\Varid{f₀}\;\Varid{x}\;\Varid{⟫}\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{θ}\;(\Varid{⟦}\;\Conid{F}\;\Varid{⟧₁}\;\Varid{f}\;\Varid{x})\;{}\<[E]%
\\
\>[5]{}\hsindent{1}{}\<[6]%
\>[6]{}\Varid{=⟪}\;\Varid{ap}\;\Varid{θ}\;(\Varid{ind-hyp}\;\Varid{x}\;\Varid{u})\;\Varid{⟫}\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{θ}\;(\Varid{⟦}\;\Conid{F}\;\Varid{⟧₁}\;\Varid{g}\;\Varid{x})\;{}\<[E]%
\\
\>[5]{}\hsindent{1}{}\<[6]%
\>[6]{}\Varid{=⟪}\;\mathbin{!}\;(\Varid{g₀}\;\Varid{x})\;\Varid{⟫}\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{g}\;(\Varid{c}\;\Varid{x})\;\Varid{∎}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\todoi{Explain \ensuremath{\Varid{ind-hyp}}}

We can define the witness of \ensuremath{\Varid{f}\;=\;\Varid{g}} as follows:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{p}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{T})\;\to \;\Varid{f}\;\Varid{x}\;=\;\Varid{g}\;\Varid{x}{}\<[E]%
\\
\>[3]{}\Varid{p}\;:\equiv\;\Varid{ind}\;(\Varid{λ}\;\Varid{x}\;\to \;\Varid{f}\;\Varid{x}\;=\;\Varid{g}\;\Varid{x})\;\Varid{step}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

which comes with the computation rule:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{p-β₀}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{FT})\;\to \;\Varid{p}\;(\Varid{c}\;\Varid{x})\;=\;\Varid{f-β₀}\;\Varid{x}\;\Varid{∙}\;\Varid{ap}\;\Varid{θ}\;(\Varid{ind-hyp}\;\Varid{x}\;(\Varid{□-lift}\;\Conid{F}\;\Varid{p}\;\Varid{x}))\;\Varid{∙}\;\mathbin{!}\;(\Varid{g-β₀}\;\Varid{x}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\todoi{say that \ensuremath{\Varid{λ=}} is fun ext}

We now need to show that our witness \ensuremath{\Varid{p}} satisfies the ``computation
rule'' \ensuremath{(\Varid{x}\;\mathbin{:}\;\Conid{FT})\;\to \;\Varid{f-β₀}\;\Varid{x}\;\Varid{∙}\;\Varid{ap}\;(\Varid{λ}\;\Varid{h}\;\Varid{→}\;\Varid{ρ}\;(\Conid{F}\;\Varid{h}\;\Varid{x}))\;\Varid{p}\;=\;\Varid{ap}\;(\Varid{λ}\;\Varid{h}\;\Varid{→}\;\Varid{h}\;(\Varid{θ}\;\Varid{x}))\;\Varid{p}\;\Varid{∙}\;\Varid{g-β₀}\;\Varid{x}}. Let \ensuremath{\Varid{x}\;\mathbin{:}\;\Conid{FT}}, then we can calculate:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{f-β₀}\;\Varid{x}\;\Varid{∙}\;\Varid{ap}\;(\Varid{λ}\;\Varid{h}\;\Varid{→}\;\Varid{θ}\;(\Conid{F}\;\Varid{h}\;\Varid{x}))\;(\Varid{λ=}\;\Varid{p})\;{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\hsindent{1}{}\<[4]%
\>[4]{}=\;\{\mskip1.5mu \Varid{ap}\;\Varid{magic}\mskip1.5mu\}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\Varid{f-β₀}\;\Varid{x}\;\Varid{∙}\;\Varid{ap}\;\Varid{θ}\;(\Varid{ind-hyp}\;\Varid{x}\;(\Varid{□-lift}\;\Conid{F}\;\Varid{p}\;\Varid{x}))\;{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\hsindent{1}{}\<[4]%
\>[4]{}=\;\{\mskip1.5mu \Varid{symmetry}\;\Varid{is}\;\Varid{involutive}\mskip1.5mu\}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\Varid{f-β₀}\;\Varid{x}\;\Varid{∙}\;\Varid{ap}\;\Varid{θ}\;(\Varid{ind-hyp}\;\Varid{x}\;(\Varid{□-lift}\;\Conid{F}\;\Varid{p}\;\Varid{x}))\;\Varid{∙}\;\mathbin{!}\;(\Varid{g-β₀}\;\Varid{x})\;\Varid{∙}\;\Varid{g-β₀}\;\Varid{x}\;{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\hsindent{1}{}\<[4]%
\>[4]{}=\;\{\mskip1.5mu \Varid{computation}\;\Varid{rule}\;\Varid{for}\;\Varid{p}\mskip1.5mu\}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\Varid{p}\;(\Varid{c}\;\Varid{x})\;\Varid{∙}\;\Varid{g-β₀}\;\Varid{x}\;{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\hsindent{1}{}\<[4]%
\>[4]{}=\;\{\mskip1.5mu \Varid{computation}\;\Varid{rule}\;\Varid{for}\;\Varid{λ=}\mskip1.5mu\}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\Varid{ap}\;(\Varid{λ}\;\Varid{h}\;\Varid{→}\;\Varid{h}\;(\Varid{c}\;\Varid{x}))\;(\Varid{λ=}\;\Varid{p})\;\Varid{∙}\;\Varid{g-β₀}\;\Varid{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We have now established initiality of \ensuremath{(\Conid{T},\Varid{c})}.

\subsection{\Ronehits}

\subsubsection{Existence}

\subsubsection{Uniqueness}

\end{document}
