\documentclass[a4paper,10pt]{article}

\usepackage{color}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}


%% Encoding, font stuff
\usepackage[utf8x]{inputenc}
\usepackage{autofe}
\usepackage{ucs}
\usepackage[greek,english]{babel}
\usepackage{bbm}
\usepackage{bbding}

%% Symbols and whatever
\usepackage{amsmath,amsthm,amssymb,amsfonts,stmaryrd}

% Format file based on agda.fmt as included in lhs2TeX distribution.

%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%
%
\ReadOnlyOnce{note.fmt}%


\providecommand\mathbbm{\mathbb}

% Path composition from The Book.
\newcommand{\ct}{%
  \mathchoice{\mathbin{\raisebox{0.5ex}{$\displaystyle\centerdot$}}}%
             {\mathbin{\raisebox{0.5ex}{$\centerdot$}}}%
             {\mathbin{\raisebox{0.25ex}{$\scriptstyle\,\centerdot\,$}}}%
             {\mathbin{\raisebox{0.1ex}{$\scriptscriptstyle\,\centerdot\,$}}}
}

\DeclareUnicodeCharacter{737}{\textsuperscript{l}}
\DeclareUnicodeCharacter{8718}{\ensuremath{\blacksquare}}
\DeclareUnicodeCharacter{8759}{::}
\DeclareUnicodeCharacter{9669}{\ensuremath{\triangleleft}}
\DeclareUnicodeCharacter{9665}{\ensuremath{\triangleleft}}
\DeclareUnicodeCharacter{8799}{\ensuremath{\stackrel{\scriptscriptstyle ?}{=}}}
\DeclareUnicodeCharacter{10214}{\ensuremath{\llbracket}}
\DeclareUnicodeCharacter{10215}{\ensuremath{\rrbracket}}
\DeclareUnicodeCharacter{946}{\ensuremath{\beta}}
\DeclareUnicodeCharacter{8729}{\ensuremath{\ct}}
\DeclareUnicodeCharacter{10218}{\ensuremath{ \{ }}
\DeclareUnicodeCharacter{10219}{\ensuremath{ \} }}
\DeclareUnicodeCharacter{8718}{\ensuremath{\blacksquare}}
\DeclareUnicodeCharacter{7496}{\ensuremath{^d}}
% TODO: This is in general not a good idea.
\providecommand\textepsilon{$\epsilon$}
\providecommand\textmu{$\mu$}
\providecommand\textbeta{$\beta$}
\providecommand\texttheta{$\theta$}


%Actually, varsyms should not occur in Agda output.

\renewcommand\Varid[1]{\mathord{\textsf{#1}}}
\let\Conid\Varid
\newcommand\Keyword[1]{\textsf{\textbf{#1}}}
\EndFmtInput










%% Layout stuff and other related goodies.
\usepackage[parfill]{parskip}
\usepackage{xspace}
\usepackage{todonotes}


%% URLs and other link stuff
\usepackage{url}
\usepackage{hyperref}
\usepackage[noabbrev]{cleveref}

\hypersetup{
  colorlinks,
  citecolor=DarkBlue,
  linkcolor=black,
  urlcolor=DarkBlue}

% Bibliography stuff
\usepackage[autostyle]{csquotes}

%% Tikz setup
\usepackage{tikz}
\usetikzlibrary{decorations.pathmorphing} % for snake lines
\usetikzlibrary{matrix}


%% Commands
\newcommand{\todoi}[1]{\todo[inline]{#1}}
\newcommand{\withoutk}{\xspace\text{\tt \char45{}\char45{}without\char45{}K}\xspace}
\newcommand{\uip}{uniqueness of identity proofs\xspace}
\newcommand{\Uip}{Uniqueness of identity proofs\xspace}
\newcommand{\hott}{homotopy type theory\xspace}
\newcommand{\Hott}{Homotopy type theory\xspace}
\newcommand{\mltt}{Martin-L\"of's type theory\xspace}
\newcommand{\hit}{higher inductive type\xspace}
\newcommand{\Hit}{Higher inductive type\xspace}
\newcommand{\hits}{higher inductive types\xspace}
\newcommand{\Hits}{Higher inductive types\xspace}
\newcommand{\oit}{ordinary inductive type\xspace}
\newcommand{\Oit}{Ordinary inductive type\xspace}
\newcommand{\oits}{ordinary inductive types\xspace}
\newcommand{\Oits}{Ordinary inductive types\xspace}
\newcommand{\zeroconstructor}{$0$-constructor\xspace}
\newcommand{\zeroconstructors}{$0$-constructors\xspace}
\newcommand{\onehit}{$1$-HIT\xspace}
\newcommand{\onehits}{$1$-HITs\xspace}
\newcommand{\oneconstructor}{$1$-constructor\xspace}
\newcommand{\oneconstructors}{$1$-constructors\xspace}
\newcommand{\twohit}{$2$-HIT\xspace}
\newcommand{\twohits}{$2$-HITs\xspace}
\newcommand{\twoconstructor}{$2$-constructor\xspace}
\newcommand{\twoconstructors}{$2$-constructors\xspace}
\newcommand{\zerovariable}{$0$-variable\xspace}
\newcommand{\onevariable}{$1$-variable\xspace}
\newcommand{\twovariable}{$2$-variable\xspace}
\newcommand{\zerovariables}{$0$-variables\xspace}
\newcommand{\onevariables}{$1$-variables\xspace}
\newcommand{\twovariables}{$2$-variables\xspace}
\newcommand{\ie}{i.e.\xspace}
\newcommand{\eg}{e.g.\xspace}
\newcommand{\Type}{\mbox{Type}}
\newcommand{\wtypes}{$W$-types\xspace}
\newcommand{\wtype}{$W$-type\xspace}
\newcommand{\ronehit}{restricted \onehit\xspace}
\newcommand{\ronehits}{restricted \onehits\xspace}
\newcommand{\Ronehit}{Restricted \onehit\xspace}
\newcommand{\Ronehits}{Restricted \onehits\xspace}

\title{Notes on \onehits}

\author{Gabe Dijkstra}

\date{}

\begin{document}

\maketitle

\section{Introduction}

\section{Describing \hits}

If we define an ordinary inductive type, we start out by writing down
a list of constructors, \eg:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Keyword{data}\;\Conid{T}\;\mathbin{:}\;\Conid{Type}\;\Keyword{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{c₀}\;{}\<[9]%
\>[9]{}\mathbin{:}\;\Conid{F₀}\;\Conid{T}\;\to \;\Conid{T}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{c₁}\;{}\<[9]%
\>[9]{}\mathbin{:}\;\Conid{F₁}\;\Conid{T}\;\to \;\Conid{T}\;{}\<[E]%
\\
\>[9]{}\vdots{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{c}_{\Varid{k}}\;{}\<[9]%
\>[9]{}\mathbin{:}\;\Varid{F}_{\Varid{k}}\;\Conid{T}\;\to \;\Conid{T}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

where all \ensuremath{\Varid{F}_{\Varid{i}}\;\mathbin{:}\;\Conid{Type}\;\to \;\Conid{Type}} are strictly positive
functors. Equivalently, we can define an inductive type with a single
constructor:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Keyword{data}\;\Conid{T}\;\mathbin{:}\;\Conid{Type}\;\Keyword{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{c}\;\mathbin{:}\;\Conid{F}\;\Conid{T}\;\to \;\Conid{T}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

where \ensuremath{\Conid{F}\;\Conid{X}\;:\equiv\;\Conid{F₀}\;\Conid{X}\;\Varid{+}\;\Conid{F₁}\;\Conid{X}\;\Varid{+}\;\hdots\;\Varid{+}\;\Varid{F}_{\Varid{k}}\;\Conid{X}}, so a single strictly
positive functor is all we need to describe an \oit.

In the case of \hits, the situation is more involved. Consider for
example the circle data type:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Keyword{data}\;\Varid{S}^1\;\mathbin{:}\;\Conid{Type}\;\Keyword{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{base}\;\mathbin{:}\;\Varid{S}^1{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{loop}\;\mathbin{:}\;\Varid{base}\;=\;\Varid{base}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

There are two things that are different from our previous
situation. Firstly, the result type of \ensuremath{\Varid{loop}} is not \ensuremath{\Varid{S}^1}, but a path
space of \ensuremath{\Varid{S}^1}: constructors are no longer algebras of functor, but a
kind of \emph{dialgebra}: the arguments as well as the result type of
a constructor may vary. Secondly, the \ensuremath{\Varid{loop}} constructor refers to the
previous constructor \ensuremath{\Varid{base}}.

The result type of a constructor can also depend on the value of its
arguments, as we see in the definition of propositional truncation as
a \hit:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Keyword{data}\;||\;\Conid{A}\;||\;\mathbin{:}\;\Conid{Type}\;\Keyword{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}[\mskip1.5mu \mathunderscore\mskip1.5mu]\;\mathbin{:}\;\Conid{A}\;\to \;||\;\Conid{A}\;||{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{trunc}\;\mathbin{:}\;(\Varid{x}\;\Varid{y}\;\mathbin{:}\;||\;\Conid{A}\;||)\;\to \;\Varid{x}\;=\;\Varid{y}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Constructors of a \hit are \emph{dependent dialgebras}. In general, a
higher inductive type looks as follows:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{37}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Keyword{data}\;\Conid{T}\;\mathbin{:}\;\Conid{Type}\;\Keyword{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{c₀}\;{}\<[11]%
\>[11]{}\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F₀}\;\Conid{T})\;{}\<[37]%
\>[37]{}\to \;\Conid{G₀}\;\Conid{T}\;\Varid{x}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{c₁}\;{}\<[11]%
\>[11]{}\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F₁}\;\Conid{T}\;\Varid{c₀})\;{}\<[37]%
\>[37]{}\to \;\Conid{G₁}\;\Conid{T}\;\Varid{c₀}\;\Varid{x}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{c₂}\;{}\<[11]%
\>[11]{}\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F₂}\;\Conid{T}\;\Varid{c₀}\;\Varid{c₁})\;{}\<[37]%
\>[37]{}\to \;\Conid{G₂}\;\Conid{T}\;\Varid{c₀}\;\Varid{c₁}\;\Varid{x}\;{}\<[E]%
\\
\>[11]{}\vdots{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{c}_{\Varid{k}+1}\;{}\<[11]%
\>[11]{}\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Varid{F}_{\Varid{k}}\;\Conid{T}\;\Varid{c₀}\;\hdots\;\Varid{c}_{\Varid{k}})\;{}\<[37]%
\>[37]{}\to \;\Varid{G}_{\Varid{k}}\;\Conid{T}\;\Varid{c₀}\;\hdots\;\Varid{c}_{\Varid{k}}\;\Varid{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We will refer to the \ensuremath{\Varid{F}_{\Varid{i}}} functors as \emph{argument} functors and the
\ensuremath{\Varid{G}_{\Varid{i}}} functors as \emph{target} functors. The types of the argument
functors are:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{F₀}\;{}\<[6]%
\>[6]{}\mathbin{:}\;\Conid{Type}\;{}\<[22]%
\>[22]{}\to \;\Conid{Type}{}\<[E]%
\\
\>[B]{}\Conid{F₁}\;{}\<[6]%
\>[6]{}\mathbin{:}\;(\Conid{F₀},\Conid{G₀})\;\Varid{-alg}\;{}\<[22]%
\>[22]{}\to \;\Conid{Type}{}\<[E]%
\\
\>[B]{}\Conid{F₂}\;{}\<[6]%
\>[6]{}\mathbin{:}\;(\Conid{F₁},\Conid{G₁})\;\Varid{-alg}\;{}\<[22]%
\>[22]{}\to \;\Conid{Type}{}\<[E]%
\\
\>[B]{}\Varid{F}_{\Varid{k}+1}\;\mathbin{:}\;(\Varid{F}_{\Varid{k}},\Varid{G}_{\Varid{k}})\;\Varid{-alg}\;{}\<[22]%
\>[22]{}\to \;\Conid{Type}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

where \ensuremath{(\Conid{F₀},\Conid{G₀})\;\Varid{-alg})} is the category whose objects are dependent
dialgebras \ensuremath{(\Conid{X}\;\mathbin{:}\;\Conid{Type})\;\Varid{×}\;(\Varid{θ}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F₀}\;\Conid{X})\;\to \;\Conid{G₀}\;\Conid{X}\;\Varid{x})}. The category
\ensuremath{(\Varid{F}_{\Varid{i}+1},\Varid{G}_{\Varid{i}+1})\;\Varid{-alg}} has as objects: \ensuremath{(\Conid{X}\;\mathbin{:}\;(\Varid{F}_{\Varid{i}},\Varid{G}_{\Varid{i}})\;\Varid{-alg})\;\Varid{×}\;(\Varid{θ}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Varid{F}_{\Varid{i}+1}\;\Conid{X})\;\to \;\Varid{G}_{\Varid{i}+1}\;\Conid{X}\;\Varid{x})}. The target functors also take the value of
the arguments as an argument, so they have the following types:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{27}{@{}>{\hspre}l<{\hspost}@{}}%
\column{35}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Conid{G₀}\;{}\<[7]%
\>[7]{}\mathbin{:}\;\int\;\Conid{Type}\;{}\<[27]%
\>[27]{}\Conid{F₀}\;{}\<[35]%
\>[35]{}\to \;\Conid{Type}{}\<[E]%
\\
\>[B]{}\Conid{G₁}\;{}\<[7]%
\>[7]{}\mathbin{:}\;\int\;(\Conid{F₀},\Conid{G₀})\;\Varid{-alg}\;{}\<[27]%
\>[27]{}\Conid{F₁}\;{}\<[35]%
\>[35]{}\to \;\Conid{Type}{}\<[E]%
\\
\>[B]{}\Conid{G₂}\;{}\<[7]%
\>[7]{}\mathbin{:}\;\int\;(\Conid{F₁},\Conid{G₁})\;\Varid{-alg}\;{}\<[27]%
\>[27]{}\Conid{F₂}\;{}\<[35]%
\>[35]{}\to \;\Conid{Type}{}\<[E]%
\\
\>[B]{}\Varid{G}_{\Varid{k}+1}\;{}\<[7]%
\>[7]{}\mathbin{:}\;\int\;(\Varid{F}_{\Varid{k}},\Varid{G}_{\Varid{k}})\;\Varid{-alg}\;{}\<[27]%
\>[27]{}\Conid{F}\;(\Varid{kp1})\;{}\<[35]%
\>[35]{}\to \;\Conid{Type}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We see that the general shape of a constructor is a dependent dialgebra:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{c}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F}\;\Conid{X})\;\to \;\Conid{G}\;(\Conid{X},\Varid{x}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

where \ensuremath{\mathbb{C}\;\mathbin{:}\;\Conid{Cat}}, \ensuremath{\Conid{F}\;\mathbin{:}\;\mathbb{C}\;\to \;\Conid{Type}} and \ensuremath{\Conid{G}\;\mathbin{:}\;\int\;\mathbb{C}\;\Conid{F}\;\to \;\Conid{Type}}, where \ensuremath{\mathbb{C}}
is \ensuremath{\Conid{Type}} or some category of dependent dialgebras, ``containing'' all
the previous constructors.

When describing \hits, we do not allow for any target functor \ensuremath{\Conid{G}}: it
must either return the type we are defining or a (possibly iterated)
path space of that type.

A \emph{\zeroconstructor} or \emph{point constructor} is a dialgebra:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{c}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F}\;\Conid{X})\;\to \;\Conid{U}\;\Conid{X}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

where \ensuremath{\mathbb{C}\;\mathbin{:}\;\Conid{Cat}}, \ensuremath{\Conid{F}\;\mathbin{:}\;\mathbb{C}\;\to \;\Conid{Type}} and \ensuremath{\Conid{U}\;\mathbin{:}\;\mathbb{C}\;\to \;\Conid{Type}} its forgetful
functor.

A \emph{\oneconstructor} is a dependent dialgebra of which the target
functor returns a path space:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{c}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F}\;\Conid{X})\;\to \;\Conid{Eq₀}\;\Conid{X}\;\Varid{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

where \ensuremath{\mathbb{C}\;\mathbin{:}\;\Conid{Cat}}, \ensuremath{\Conid{F},\Conid{U}\;\mathbin{:}\;\mathbb{C}\;\to \;\Conid{Type}}, and \ensuremath{\Conid{Eq₀}\;\mathbin{:}\;\int\;\mathbb{C}\;\Conid{F}\;\to \;\Conid{Type}} is the functor:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Conid{Eq₀}\;(\Conid{X},\Varid{x})\;:\equiv\;(\Varid{l₀}\;\Conid{X}\;\Varid{x}\;=\;\Varid{r₀}\;\Conid{X}\;\Varid{x}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

where \ensuremath{\Varid{l₀},\Varid{r₀}\;\mathbin{:}\;\Conid{F}\;\to \;\Conid{U}} are natural transformations.

For higher path constructors, we have to specify a tower of natural
transformations, specifying the end points at every level. To specify
an \ensuremath{(\Varid{k+1})}-constructor, we need to give the natural transformations:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{l₀},\Varid{r₀}\;{}\<[11]%
\>[11]{}\mathbin{:}\;\Conid{F}\;\to \;\Conid{U}{}\<[E]%
\\
\>[3]{}\Varid{l₁},\Varid{r₁}\;{}\<[11]%
\>[11]{}\mathbin{:}\;\Varid{1}\;\to \;\Conid{Eq₀}{}\<[E]%
\\
\>[3]{}\Varid{l₂},\Varid{r₂}\;{}\<[11]%
\>[11]{}\mathbin{:}\;\Varid{1}\;\to \;\Conid{Eq₁}\;{}\<[E]%
\\
\>[11]{}\vdots{}\<[E]%
\\
\>[3]{}\Varid{l}_{\Varid{k}},\Varid{r}_{\Varid{k}}\;{}\<[11]%
\>[11]{}\mathbin{:}\;\Varid{1}\;\to \;\Varid{Eq}_{\Varid{k}-1}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

where \ensuremath{\Varid{Eq}_{\Varid{i}}\;\Conid{X}\;\Varid{x}\;:\equiv\;(\Varid{l}_{\Varid{i}}\;\Conid{X}\;\Varid{x}\;=\;\Varid{r}_{\Varid{i}}\;\Conid{X}\;\Varid{x})}. \ensuremath{\Conid{Eqn}} is then the target
functor we are interested in.

\subsection{Strict positivity}

Apart from the restrictions on targets, we also want all functors
involved to be strictly positive. In the case of \oits, we also have
this restriction. An example of an inductive type which constructor is
not strictly positive is the following:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Keyword{data}\;\Conid{Term}\;\mathbin{:}\;\Conid{Type}\;\Keyword{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{lam}\;\mathbin{:}\;(\Conid{Term}\;\to \;\Conid{Term})\;\to \;\Conid{Term}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Using the type \ensuremath{\Conid{Term}}, we can find inhabitants of the empty type. We
therefore only consider inductive types defined by strictly positive
functors, \ie containers. Containers however only describe functors
\ensuremath{\Conid{Type}\;\to \;\Conid{Type}}. An example of that shows that we need a notion of
strict positivity for any functor into \ensuremath{\Conid{Type}} is that of the ``initial
field''. If we write down the axioms of an algebraic structure as
constructors, the inductive type we get is then the initial object in
the category of that algebraic structure, \ie  we can define a type \ensuremath{\Conid{T}}
with the monoid axioms as constructors:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Keyword{data}\;\Conid{T}\;\mathbin{:}\;\Conid{Type}\;\Keyword{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{uip}\;\mathbin{:}\;(\Varid{x}\;\Varid{y}\;\mathbin{:}\;\Conid{T})\;(\Varid{p}\;\Varid{q}\;\mathbin{:}\;\Varid{x}\;=\;\Varid{y})\;\to \;\Varid{p}\;=\;\Varid{q}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathunderscore∙\mathunderscore\;\mathbin{:}\;\Conid{T}\;\to \;\Conid{T}\;\to \;\Conid{T}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{assoc}\;\mathbin{:}\;(\Varid{x}\;\Varid{y}\;\Varid{z}\;\mathbin{:}\;\Conid{T})\;\to \;(\Varid{x}\;\Varid{∙}\;\Varid{y})\;\Varid{∙}\;\Varid{z}\;=\;\Varid{x}\;\Varid{∙}\;(\Varid{y}\;\Varid{∙}\;\Varid{z}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{e}\;\mathbin{:}\;\Conid{T}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{e-unit-l}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{T})\;\to \;\Varid{e}\;\Varid{∙}\;\Varid{x}\;=\;\Varid{x}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{e-unit-r}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{T})\;\to \;\Varid{x}\;\Varid{∙}\;\Varid{e}\;=\;\Varid{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\ensuremath{\Conid{T}} is equivalent to the unit type, which is the initial object in the
category of monoids. If we now were to write down the axioms of a
field, we run into trouble: there is no initial object in the category
of fields. The culprit is the inverse operation, which has the type:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{inv}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{T})\;\to \;(\Varid{x}\;=\;\Varid{0}\;\to \;\Varid{⊥})\;\to \;\Conid{T}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The constructor \ensuremath{\Varid{0}} occurs negatively in this constructor.

To generalise the notion of strict positivity, we can generalise the
notion of containers to not only describe functors \ensuremath{\Conid{Type}\;\to \;\Conid{Type}}, but
functors \emph{into} \ensuremath{\Conid{Type}} from any \ensuremath{\mathbb{C}\;\mathbin{:}\;\Conid{Cat}}. A \emph{generalised
  container} is given by:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Conid{S}\;\mathbin{:}\;\Conid{Type}{}\<[E]%
\\
\>[3]{}\Conid{P}\;\mathbin{:}\;\Conid{S}\;\to \;|\;\mathbb{C}\;|{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Its extension is then defined as:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{⟦}\;\Conid{S}\;\Varid{◁}\;\Conid{P}\;\Varid{⟧}\;\mathbin{:}\;\mathbb{C}\;\to \;\Conid{Type}{}\<[E]%
\\
\>[3]{}\Varid{⟦}\;\Conid{S}\;\Varid{◁}\;\Conid{P}\;\Varid{⟧}\;\Conid{X}\;:\equiv\;(\Varid{s}\;\mathbin{:}\;\Conid{S})\;\Varid{×}\;\mathbb{C}\;(\Conid{P}\;\Varid{s},\Conid{X}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

with the action on morphisms defined as:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{⟦}\;\Conid{S}\;\Varid{◁}\;\Conid{P}\;\Varid{⟧}\;\mathbin{:}\;\mathbb{C}\;(\Conid{X},\Conid{Y})\;\to \;\Varid{⟦}\;\Conid{S}\;\Varid{◁}\;\Conid{P}\;\Varid{⟧}\;\Conid{X}\;\to \;\Varid{⟦}\;\Conid{S}\;\Varid{◁}\;\Conid{P}\;\Varid{⟧}\;\Conid{Y}{}\<[E]%
\\
\>[3]{}\Varid{⟦}\;\Conid{S}\;\Varid{◁}\;\Conid{P}\;\Varid{⟧}\;\Varid{f}\;(\Varid{s},\Varid{t})\;:\equiv\;(\Varid{s},\Varid{f}\;\Varid{∘}\;\Varid{t}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Just as with ordinary containers, we can define container morphisms
for generalised containers in the standard way: for containers \ensuremath{\Conid{S}\;\Varid{◁}\;\Conid{P}}
and \ensuremath{\Conid{T}\;\Varid{◁}\;\Conid{Q}}, a container morphism \ensuremath{\Conid{S}\;\Varid{◁}\;\Conid{P}\;\to \;\Conid{T}\;\Varid{◁}\;\Conid{Q}} is comprised of:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{f}\;\mathbin{:}\;\Conid{S}\;\to \;\Conid{T}{}\<[E]%
\\
\>[3]{}\Varid{g}\;\mathbin{:}\;(\Varid{a}\;\mathbin{:}\;\Conid{S})\;\to \;\mathbb{C}\;(\Conid{Q}\;(\Varid{f}\;\Varid{a}),\Conid{P}\;\Varid{a}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

with its action of objects defined as:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{⟦}\;(\Varid{f},\Varid{g})\;\Varid{⟧}\;\mathbin{:}\;(\Conid{X}\;\mathbin{:}\;|\;\mathbb{C}\;|)\;\to \;\Varid{⟦}\;\Conid{S}\;\Varid{◁}\;\Conid{P}\;\Varid{⟧}\;\Conid{X}\;\to \;\Varid{⟦}\;\Conid{T}\;\Varid{◁}\;\Conid{Q}\;\Varid{⟧}\;\Conid{X}{}\<[E]%
\\
\>[3]{}\Varid{⟦}\;(\Varid{f},\Varid{g})\;\Varid{⟧}\;\Conid{X}\;(\Varid{s},\Varid{t})\;:\equiv\;(\Varid{f}\;\Varid{s},\Varid{t}\;\Varid{∘}\;(\Varid{g}\;\Varid{s})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection{\Hits as a sequence of monads}

Given a strictly positive functor \ensuremath{\Conid{F}\;\mathbin{:}\;\Conid{Type}\;\to \;\Conid{Type}}, we can consider
its category of algebras \ensuremath{\Conid{F-alg}}. \ensuremath{\Conid{F-alg}} has a forgetful functor \ensuremath{\Conid{U}\;\mathbin{:}\;\Conid{F-alg}\;\to \;\Conid{Type}}, which has a left adjoint \ensuremath{\Conid{L}\;\mathbin{:}\;\Conid{Type}\;\to \;\Conid{F-alg}} that maps
a type to its free \ensuremath{\Conid{F}}-algebra. Note that plugging in the initial
object in \ensuremath{\Conid{Type}}, \ie the empty type into \ensuremath{\Conid{L}} gives us the initial
object in \ensuremath{\Conid{F-alg}}, as left adjoints preserve colimits. The monad \ensuremath{\Conid{UL}}
is called the \emph{free monad} of \ensuremath{\Conid{F}}, also denoted as \ensuremath{\Conid{F}\;\Varid{*}}. This
monad has the property that the category of \ensuremath{\Conid{F}}-algebras is equivalent
to the category of monad algebras of \ensuremath{\Conid{F}\;\Varid{*}}. \Hits can be contrasted to
\oits as being characterised by a more general class of monads than
just free monads.

\section{\Ronehits}

Instead of considering a \hit with arbitrarily many constructors, we
can restrict ourselves to having two constructors: a \zeroconstructor
followed by a \oneconstructor. The data we need to supply for this is:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Conid{F₀}\;\mathbin{:}\;\Conid{Type}\;\to \;\Conid{Type}{}\<[E]%
\\
\>[3]{}\Conid{F₁}\;\mathbin{:}\;\Conid{F₀-alg}\;\to \;\Conid{Type}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

with the target of the \oneconstructor given by:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Conid{G}\;\mathbin{:}\;\int\;(\Conid{F₀-alg})\;\Conid{F₁}\;\to \;\Conid{Type}{}\<[E]%
\\
\>[3]{}\Conid{G}\;\Conid{X}\;\Varid{θ}\;\Varid{x}\;:\equiv\;(\Varid{l}\;\Conid{X}\;\Varid{θ}\;\Varid{x}\;=\;\Varid{r}\;\Conid{X}\;\Varid{θ}\;\Varid{x}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

for natural transformations \ensuremath{\Varid{l},\Varid{r}\;\mathbin{:}\;\Conid{F₁}\;\to \;\Conid{U}} where \ensuremath{\Conid{U}\;\mathbin{:}\;\Conid{F₀-alg}\;\to \;\Conid{Type}} the forgetful functor. If \ensuremath{\Conid{F₁}} factors through \ensuremath{\Conid{U}}, \ie the
arguments of the \oneconstructor do not refer to the \zeroconstructor,
then can simplify the situation even further. Suppose \ensuremath{\Conid{F₁}\;=\;\Conid{F₁'}\;\Varid{∘}\;\Conid{U}}
for some \ensuremath{\Conid{F₁'}\;\mathbin{:}\;\Conid{Type}\;\to \;\Conid{Type}}, natural transformations \ensuremath{\Conid{F₁}\;\to \;\Conid{U}} can
be given by natural transformations \ensuremath{\Conid{F₁'}\;\to \;\Conid{F₀}\;\Varid{*}}, where \ensuremath{\Conid{F₀}\;\Varid{*}} is the
free monad of \ensuremath{\Conid{F₀}}. Recall that \ensuremath{\Conid{U}} has a left adjoint \ensuremath{\Conid{L}} such that
\ensuremath{\Conid{F₀}\;\Varid{*}\;=\;\Conid{UL}}. Since \ensuremath{\Conid{U}} has a left adjoint, it is representable, for
any \ensuremath{\Conid{X}\;\mathbin{:}\;\Conid{Type}}:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Conid{U}\;\Conid{X}\;{}\<[8]%
\>[8]{}=\;\Varid{1}\;\to \;\Conid{U}\;\Conid{X}\;{}\<[E]%
\\
\>[8]{}=\;\Conid{F₀-alg}\;(\Conid{L₁},\Conid{U}\;\Conid{X}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

If \ensuremath{\Conid{F₁'}\;\equiv\;\Conid{S}\;\Varid{◁}\;\Conid{P}}, then we can characterise natural transformations \ensuremath{\Conid{F₁}\;\to \;\Conid{U}} as container morphisms. We can calculate the container
representation of the composition \ensuremath{\Conid{F₁'}\;\Varid{∘}\;\Conid{U}} as follows: suppose \ensuremath{\Conid{X}\;\mathbin{:}\;\Conid{Type}}, then:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Conid{F₁'}\;(\Conid{U}\;\Conid{X})\;{}\<[14]%
\>[14]{}=\;\Conid{F₁'}\;(\Conid{F₀-alg}\;(\Conid{L₁},\Conid{X}))\;{}\<[E]%
\\
\>[14]{}=\;(\Varid{s}\;\mathbin{:}\;\Conid{S})\;\Varid{×}\;(\Conid{P}\;\Varid{s}\;\to \;\Conid{F₀-alg}\;(\Conid{L₁},\Conid{X}))\;{}\<[E]%
\\
\>[14]{}=\;(\Varid{s}\;\mathbin{:}\;\Conid{S})\;\Varid{×}\;(\Conid{P}\;\Varid{s}\;\to \;\Varid{1}\;\to \;\Conid{U}\;\Conid{X})\;{}\<[E]%
\\
\>[14]{}=\;(\Varid{s}\;\mathbin{:}\;\Conid{S})\;\Varid{×}\;(\Conid{P}\;\Varid{s}\;\to \;\Conid{U}\;\Conid{X})\;{}\<[E]%
\\
\>[14]{}=\;(\Varid{s}\;\mathbin{:}\;\Conid{S})\;\Varid{×}\;(\Conid{F₀-alg}\;(\Conid{L}\;(\Conid{P}\;\Varid{s}),\Conid{X})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

So the container representation of \ensuremath{\Conid{F₁'}\;\Varid{∘}\;\Conid{U}} is \ensuremath{\Conid{S}\;\Varid{◁}\;\Conid{L}\;\Varid{∘}\;\Conid{P}}. Using
this we can derive the following:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Conid{F₁}\;\to \;\Conid{U}\;{}\<[E]%
\\
\>[3]{}\hsindent{1}{}\<[4]%
\>[4]{}=\;\{\mskip1.5mu \Varid{definition}\;\Varid{of}\;\Conid{F₁}\mskip1.5mu\}{}\<[E]%
\\
\>[3]{}\Conid{F₁'}\;\Varid{∘}\;\Conid{U}\;\to \;\Conid{U}\;{}\<[E]%
\\
\>[3]{}\hsindent{1}{}\<[4]%
\>[4]{}=\;\{\mskip1.5mu \Varid{container}\;\Varid{morphisms}\mskip1.5mu\}{}\<[E]%
\\
\>[3]{}(\Varid{s}\;\mathbin{:}\;\Conid{S})\;\to \;\Conid{U}\;(\Conid{L}\;(\Conid{P}\;\Varid{s}))\;{}\<[E]%
\\
\>[3]{}\hsindent{1}{}\<[4]%
\>[4]{}=\;\{\mskip1.5mu \Varid{definition}\;\Varid{of}\;\Conid{F}\;\Varid{*}\mskip1.5mu\}{}\<[E]%
\\
\>[3]{}(\Varid{s}\;\mathbin{:}\;\Conid{S})\;\to \;\Conid{F₀}\;\Varid{*}\;(\Conid{P}\;\Varid{s})\;{}\<[E]%
\\
\>[3]{}\hsindent{1}{}\<[4]%
\>[4]{}=\;\{\mskip1.5mu \Varid{container}\;\Varid{morphisms}\mskip1.5mu\}{}\<[E]%
\\
\>[3]{}\Conid{F₁'}\;\to \;\Conid{F₀}\;\Varid{*}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The data we need to describe a \ronehit consists of:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Conid{F₀}\;\mathbin{:}\;\Conid{Type}\;\to \;\Conid{Type}{}\<[E]%
\\
\>[3]{}\Conid{F₁}\;\mathbin{:}\;\Conid{Type}\;\to \;\Conid{Type}{}\<[E]%
\\
\>[3]{}\Varid{l},\Varid{r}\;\mathbin{:}\;\Conid{F₁}\;\to \;\Conid{F₀}\;\Varid{*}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

where \ensuremath{\Conid{F₀},\Conid{F₁}} are given as container and \ensuremath{\Varid{l},\Varid{r}} as container
morphisms. Given these data, the \ronehit then looks as follows:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Keyword{data}\;\Conid{T}\;\mathbin{:}\;\Conid{Type}\;\Keyword{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{c₀}\;\mathbin{:}\;\Conid{F₀}\;\Conid{T}\;\to \;\Conid{T}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{c₁}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F₁}\;\Conid{T})\;\to \;\Varid{c₀}\;\Varid{*}\;(\Varid{l}\;\Varid{x})\;=\;\Varid{c₀}\;\Varid{*}\;(\Varid{r}\;\Varid{x}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

where \ensuremath{\Varid{c₀}\;\Varid{*}\;\mathbin{:}\;\Conid{F₀}\;\Varid{*}\;\Conid{T}\;\to \;\Conid{T}} is the lifting of the \ensuremath{\Conid{F₀}}-algebra \ensuremath{\Varid{c₀}\;\mathbin{:}\;\Conid{F₀}\;\Conid{T}\;\to \;\Conid{T}} to a (monad) \ensuremath{\Conid{F₀}\;\Varid{*}}-algebra.

The advantage of restricting ourselves to the above situation is that
we can give the description of a \hit using only ordinary containers
and container morphisms. This avoids dealing with the coherence
problems that stem from defining categories of algebras, needed to
give the generalised containers for the constructors.

Many \hits we see ``in the wild'' can be captured by this approach,
such as the circle and \ensuremath{\Varid{n}}-truncation.

One limitation however is that it does not handle ``nested'' \hits
directly. The following example is not expressible, as the functor \ensuremath{||\;\mathunderscore\;||\;\mathbin{:}\;\Conid{Type}\;\to \;\Conid{Type}} is not a container:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Keyword{data}\;\Conid{T}\;\mathbin{:}\;\Conid{Type}\;\Keyword{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{c}\;\mathbin{:}\;||\;\Conid{T}\;||\;\to \;\Conid{T}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\section{Algebras}

Before we set out to show that induction implies homotopy initiality
and vice versa, we need to define exactly what we mean when we talk
about these concepts. First we will define the relevant concepts for
ordinary \ensuremath{\Conid{F}}-algebras and later give the definitions of algebras for
\ronehits.

The type of \emph{\ensuremath{\Conid{F}}-algebras}, or simply \emph{algebras}, can be
defined as follows:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Conid{Alg}\;:\equiv\;(\Conid{X}\;\mathbin{:}\;\Conid{Type})\;\Varid{×}\;(\Varid{θ}\;\mathbin{:}\;\Conid{F}\;\Conid{X}\;\to \;\Conid{X}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

where the type of algebra morphisms is defined as functions between
the carriers such that it respects both algebra structures:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Conid{Alg-hom}\;\mathbin{:}\;\Conid{Alg}\;\to \;\Conid{Alg}\;\to \;\Conid{Type}{}\<[E]%
\\
\>[3]{}\Conid{Alg-hom}\;(\Conid{X},\Varid{θ})\;(\Conid{Y},\Varid{ρ})\;:\equiv\;{}\<[E]%
\\
\>[3]{}\hsindent{5}{}\<[8]%
\>[8]{}(\Varid{f}\;\mathbin{:}\;\Conid{X}\;\to \;\Conid{Y})\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{×}\;{}\<[8]%
\>[8]{}(\Varid{f-β₀}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F}\;\Conid{X})\;\to \;\Varid{f}\;(\Varid{θ}\;\Varid{x})\;=\;\Varid{ρ}\;(\Conid{F}\;\Varid{f}\;\Varid{x})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The witness of commutativity has suggestively been named \ensuremath{\Varid{f-β₀}} as
this corresponds the computation rule for the recursion and induction
principles.

\subsection{Homotopy initial algebras}

We call an algebra \ensuremath{(\Conid{X},\Varid{θ})} \emph{homotopy initial} if it has the
property that for every algebra \ensuremath{(\Conid{Y},\Varid{ρ})}, \ensuremath{\Conid{Alg-hom}\;(\Conid{X},\Varid{θ})\;(\Conid{Y},\Varid{ρ})}
is contractible, \ie:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{is-initial}\;\mathbin{:}\;\Conid{Alg}\;\to \;\Conid{Type}{}\<[E]%
\\
\>[3]{}\Varid{is-initial}\;\Varid{θ}\;{}\<[17]%
\>[17]{}:\equiv\;{}\<[21]%
\>[21]{}(\Varid{ρ}\;\mathbin{:}\;\Conid{Alg})\;\Varid{→}\;\Varid{is-contr}\;(\Conid{Alg-hom}\;\Varid{θ}\;\Varid{ρ})\;{}\<[E]%
\\
\>[17]{}\equiv\;{}\<[21]%
\>[21]{}(\Varid{ρ}\;\mathbin{:}\;\Conid{Alg})\;\Varid{→}\;(\Varid{f}\;\mathbin{:}\;\Conid{Alg-hom}\;\Varid{θ}\;\Varid{ρ})\;\Varid{×}\;((\Varid{g}\;\mathbin{:}\;\Conid{Alg-hom}\;\Varid{θ}\;\Varid{ρ})\;\Varid{→}\;\Varid{f}\;=\;\Varid{g}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Note that this definition does not refer to how \ensuremath{\Conid{Alg}} and \ensuremath{\Conid{Alg-hom}}
are defined exactly, so this definition also holds for the algebras
for \ronehits.

\subsubsection{Equality of algebra morphisms}

As we see in the definition of homotopy initiality, we need to be able
to talk about equality of algebra morphisms. Given algebras \ensuremath{(\Conid{X},\Varid{θ})}
and \ensuremath{(\Conid{Y},\Varid{ρ})} and morphisms \ensuremath{(\Varid{f},\Varid{f-β₀})} and \ensuremath{(\Varid{g},\Varid{g-β₀})} between
them, we know that, by equality on Σ-types, the following holds:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[4]{}(\Varid{f},\Varid{f-β₀})\;=\;(\Varid{g},\Varid{g-β₀}){}\<[E]%
\\
\>[B]{}\Varid{≃}\;{}\<[4]%
\>[4]{}(\Varid{p}\;\mathbin{:}\;\Varid{f}\;=\;\Varid{g}){}\<[E]%
\\
\>[B]{}\Varid{×}\;{}\<[4]%
\>[4]{}(\Varid{p-β₀}\;\mathbin{:}\;\Varid{transport}\;(\Varid{λ}\;\Varid{h}\;.\;(\Varid{x}\;\mathbin{:}\;\Conid{F}\;\Conid{X})\;\Varid{→}\;\Varid{h}\;(\Varid{θ}\;\Varid{x})\;=\;\Varid{ρ}\;(\Conid{F}\;\Varid{h}\;\Varid{x}))\;\Varid{f-β₀}\;=\;\Varid{g-β₀}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We not only need to show that the functions \ensuremath{\Varid{f}} and \ensuremath{\Varid{g}} are equal, but
also that their β-laws are in some sense compatible with eachother,
respecting the equality \ensuremath{\Varid{f}\;=\;\Varid{g}}.

As it turns out, the above is equivalent to something which is more
convenient in subsequent proofs:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[4]{}\Varid{transport}\;(\Varid{λ}\;\Varid{h}\;.\;(\Varid{x}\;\mathbin{:}\;\Conid{F}\;\Conid{X})\;\Varid{→}\;\Varid{h}\;(\Varid{θ}\;\Varid{x})\;=\;\Varid{ρ}\;(\Conid{F}\;\Varid{h}\;\Varid{x}))\;\Varid{p}\;\Varid{f-β₀}\;=\;\Varid{g-β₀}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{≃}\;\{\mskip1.5mu \Varid{transport}\;\Varid{over}\;\Conid{Π-types}\mskip1.5mu\}\;{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}(\Varid{λ}\;\Varid{x}\;.\;\Varid{transport}\;(\Varid{λ}\;\Varid{h}\;.\;\Varid{h}\;(\Varid{θ}\;\Varid{x})\;=\;\Varid{ρ}\;(\Conid{F}\;\Varid{h}\;\Varid{x}))\;\Varid{p}\;(\Varid{f-β₀}\;\Varid{x}))\;=\;\Varid{g-β₀}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{≃}\;\{\mskip1.5mu \Varid{function}\;\Varid{extensionality}\mskip1.5mu\}\;{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}((\Varid{x}\;\mathbin{:}\;\Conid{A})\;\Varid{→}\;\Varid{transport}\;(\Varid{λ}\;\Varid{h}\;.\;\Varid{h}\;(\Varid{θ}\;\Varid{x})\;=\;\Varid{ρ}\;(\Conid{F}\;\Varid{h}\;\Varid{x}))\;\Varid{p}\;(\Varid{f-β₀}\;\Varid{x})\;=\;\Varid{g-β₀}\;\Varid{x}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{≃}\;\{\mskip1.5mu \Varid{transporting}\;\Varid{over}\;\Varid{equalities}\mskip1.5mu\}\;{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\mathbin{!}\;(\Varid{ap}\;(\Varid{λ}\;\Varid{h}\;.\;\Varid{h}\;(\Varid{θ}\;\Varid{x}))\;\Varid{p})\;\Varid{∙}\;\Varid{f-β₀}\;\Varid{x}\;\Varid{∙}\;\Varid{ap}\;(\Varid{λ}\;\Varid{h}\;.\;\Varid{ρ}\;(\Conid{F}\;\Varid{h}\;\Varid{x}))\;\Varid{p}\;=\;\Varid{g-β₀}\;\Varid{x}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{≃}\;\{\mskip1.5mu \Varid{path}\;\Varid{algebra}\mskip1.5mu\}\;{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{f-β₀}\;\Varid{x}\;\Varid{∙}\;\Varid{ap}\;(\Varid{λ}\;\Varid{h}\;.\;\Varid{ρ}\;(\Conid{F}\;\Varid{h}\;\Varid{x}))\;\Varid{p}\;=\;\Varid{ap}\;(\Varid{λ}\;\Varid{h}\;.\;\Varid{h}\;(\Varid{θ}\;\Varid{x}))\;\Varid{p}\;\Varid{∙}\;\Varid{g-β₀}\;\Varid{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The last equation tells us that showing that two algebra morphisms are
equal is somewhat like giving a dialgebra morphism from the witness of
the β-law for \ensuremath{\Varid{f}} to that of \ensuremath{\Varid{g}}, as we can see if we draw the
corresponding diagram:

\begin{center}
  \begin{tikzpicture}[description/.style={fill=white,inner sep=2pt}]
    \matrix (m) [matrix of math nodes, 
                row sep=4.5em,
                column sep=3.5em,
                text height=1.5ex,
                text depth=0.25ex]
 { \ensuremath{\Varid{f}\;(\Varid{θ}\;\Varid{x})} & & \ensuremath{\Varid{ρ}\;(\Conid{F}\;\Varid{f}\;\Varid{x})} \\
   \ensuremath{\Varid{g}\;(\Varid{θ}\;\Varid{x})} & & \ensuremath{\Varid{ρ}\;(\Conid{F}\;\Varid{g}\;\Varid{x})} \\ };

  \path[->] (m-1-1) edge[decorate] node[auto]       {\ensuremath{\Varid{f-β₀}\;\Varid{x}}} (m-1-3);
  \path[->] (m-1-3) edge[decorate] node[auto]       {\ensuremath{\Varid{ap}\;(\Varid{λ}\;\Varid{h}\;.\;\Varid{ρ}\;(\Conid{F}\;\Varid{h}\;\Varid{x}))\;\Varid{p}}} (m-2-3);
  \path[->] (m-1-1) edge[decorate] node[auto,swap]  {\ensuremath{\Varid{ap}\;(\Varid{λ}\;\Varid{h}\;.\;\Varid{h}\;(\Varid{θ}\;\Varid{x}))\;\Varid{p}}} (m-2-1);
  \path[->] (m-2-1) edge[decorate] node[auto]       {\ensuremath{\Varid{g-β₀}\;\Varid{x}}} (m-2-3);
  \end{tikzpicture}
\end{center}

\subsection{Algebras for \ronehit descriptions}

For algebras of \ronehits, the structure starts out similar to the
above with an added function for the \oneconstructor. 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Conid{Alg}\;:\equiv\;{}\<[E]%
\\
\>[3]{}\hsindent{5}{}\<[8]%
\>[8]{}(\Conid{X}\;\mathbin{:}\;\Conid{Type})\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{×}\;{}\<[8]%
\>[8]{}(\Varid{θ₀}\;\mathbin{:}\;\Conid{F₀}\;\Conid{X}\;\to \;\Conid{X})\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{×}\;{}\<[8]%
\>[8]{}(\Varid{θ₁}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F₁}\;\Conid{X})\;\to \;\Varid{l}\;(\Varid{θ₀}\;\Varid{*}\;\Varid{x})\;=\;\Varid{r}\;(\Varid{θ₀}\;\Varid{*}\;\Varid{x})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Recall that \ensuremath{\Varid{θ₀}} is an \ensuremath{\Conid{F₀}}-algebra and \ensuremath{\Varid{θ₁}} is a dependent dialgebra
by defining the target functor \ensuremath{\Conid{G}}:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Conid{G}\;\mathbin{:}\;\Varid{∫}\;\Conid{F₀-alg}\;\Conid{F₁}\;\to \;\Conid{Type}{}\<[E]%
\\
\>[3]{}\Conid{G}\;((\Conid{X},\Varid{θ}),\Varid{x})\;:\equiv\;(\Varid{l}\;(\Varid{θ₀}\;\Varid{*}\;\Varid{x})\;=\;\Varid{r}\;(\Varid{θ₀}\;\Varid{*}\;\Varid{x})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Its hom-types can be defined as follows:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{31}{@{}>{\hspre}l<{\hspost}@{}}%
\column{36}{@{}>{\hspre}l<{\hspost}@{}}%
\column{42}{@{}>{\hspre}l<{\hspost}@{}}%
\column{50}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Conid{Alg-hom}\;\mathbin{:}\;\Conid{Alg}\;\to \;\Conid{Alg}\;\to \;\Conid{Type}{}\<[E]%
\\
\>[3]{}\Conid{Alg-hom}\;(\Conid{X},\Varid{θ})\;(\Conid{Y},\Varid{ρ})\;:\equiv\;{}\<[E]%
\\
\>[3]{}\hsindent{5}{}\<[8]%
\>[8]{}(\Varid{f}\;\mathbin{:}\;\Conid{X}\;\to \;\Conid{Y})\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{×}\;{}\<[8]%
\>[8]{}(\Varid{f-β₀}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F₀}\;\Conid{X})\;\to \;{}\<[36]%
\>[36]{}\Varid{f}\;{}\<[42]%
\>[42]{}(\Varid{θ₀}\;\Varid{x})\;{}\<[50]%
\>[50]{}=\;\Varid{ρ₀}\;(\Conid{F₀}\;\Varid{f}\;\Varid{x}))\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{×}\;{}\<[8]%
\>[8]{}(\Varid{f-β₁}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F₁}\;\Conid{X})\;\to \;{}\<[31]%
\>[31]{}\Conid{G}\;\Varid{x}\;{}\<[36]%
\>[36]{}\Varid{f},\Varid{f₀}\;{}\<[42]%
\>[42]{}(\Varid{θ₁}\;\Varid{x})\;{}\<[50]%
\>[50]{}=\;\Varid{ρ₁}\;(\Conid{F₁}\;\Varid{f}\;\Varid{x})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks



\subsubsection{Equality of algebra morphisms}

As we saw previously, we also need to consider what equalities of
algebra morphisms look like.

\begin{center}
  \begin{tikzpicture}[description/.style={fill=white,inner sep=2pt}]
    \matrix (m) [matrix of math nodes, 
                row sep=4.5em,
                column sep=3.5em,
                text height=1.5ex,
                text depth=0.25ex]
 { \ensuremath{\Varid{f}\;(\Varid{θ₀}\;\Varid{x})} & & \ensuremath{\Varid{ρ₀}\;(\Conid{F₀}\;\Varid{f}\;\Varid{x})} \\
   \ensuremath{\Varid{g}\;(\Varid{θ₀}\;\Varid{x})} & & \ensuremath{\Varid{ρ₀}\;(\Conid{F₀}\;\Varid{g}\;\Varid{x})} \\ };

  \path[->] (m-1-1) edge[decorate] node[auto]       {\ensuremath{\Varid{f-β₀}\;\Varid{x}}} (m-1-3);
  \path[->] (m-1-3) edge[decorate] node[auto]       {\ensuremath{\Varid{ap}\;(\Varid{λ}\;\Varid{h}\;.\;\Varid{ρ₀}\;(\Conid{F}\;\Varid{h}\;\Varid{x}))\;\Varid{p}}} (m-2-3);
  \path[->] (m-1-1) edge[decorate] node[auto,swap]  {\ensuremath{\Varid{ap}\;(\Varid{λ}\;\Varid{h}\;.\;\Varid{h}\;(\Varid{θ₀}\;\Varid{x}))\;\Varid{p}}} (m-2-1);
  \path[->] (m-2-1) edge[decorate] node[auto]       {\ensuremath{\Varid{g-β₀}\;\Varid{x}}} (m-2-3);
  \end{tikzpicture}
\end{center}

along with

\begin{center}
  \begin{tikzpicture}[description/.style={fill=white,inner sep=2pt}]
    \matrix (m) [matrix of math nodes, 
                row sep=4.5em,
                column sep=3.5em,
                text height=1.5ex,
                text depth=0.25ex]
 { \ensuremath{\Conid{G}\;\Varid{x}\;\Varid{f},\Varid{f₀}\;(\Varid{θ₁}\;\Varid{x})} & & \ensuremath{\Varid{ρ₁}\;(\Conid{F₁}\;\Varid{f}\;\Varid{x})} \\
   \ensuremath{\Conid{G}\;\Varid{x}\;\Varid{g},\Varid{g₀}\;(\Varid{θ₁}\;\Varid{x})} & & \ensuremath{\Varid{ρ₁}\;(\Conid{F₁}\;\Varid{g}\;\Varid{x})} \\ };

  \path[->] (m-1-1) edge[decorate] node[auto]       {\ensuremath{\Varid{f-β₁}\;\Varid{x}}} (m-1-3);
  \path[->] (m-1-3) edge[decorate] node[auto]       {\ensuremath{\Varid{ap}\;(\Varid{λ}\;(\Varid{h},\Varid{h₀})\;.\;\Varid{ρ₁}\;(\Conid{F}\;\Varid{h}\;\Varid{x}))\;(\Varid{p},\Varid{p₀})}} (m-2-3);
  \path[->] (m-1-1) edge[decorate] node[auto,swap]  {\ensuremath{\Varid{ap}\;(\Varid{λ}\;(\Varid{h},\Varid{h₀})\;.\;\Conid{G}\;\Varid{x}\;(\Varid{h},\Varid{h₀})\;(\Varid{θ₁}\;\Varid{x})\;(\Varid{p},\Varid{p₀})}} (m-2-1);
  \path[->] (m-2-1) edge[decorate] node[auto]       {\ensuremath{\Varid{g-β₁}\;\Varid{x}}} (m-2-3);
  \end{tikzpicture}
\end{center}


\section{Induction}

Now we know what the algebras for \ronehits look like, characterising
\ronehits as an initial algebra tells us what the constructors look
like and gives us a recursion principle with its computation
rule. However, it does not immediately reveal to us what the induction
principle looks like.

Let us first look at the induction principle for natural numbers:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Conid{Nat-ind}\;\mathbin{:}\;{}\<[E]%
\\
\>[3]{}\hsindent{6}{}\<[9]%
\>[9]{}(\Conid{P}\;\mathbin{:}\;\Conid{Nat}\;\to \;\Conid{Type})\;{}\<[E]%
\\
\>[3]{}\hsindent{6}{}\<[9]%
\>[9]{}(\Varid{m-zero}\;\mathbin{:}\;\Conid{P}\;\Varid{zero})\;{}\<[E]%
\\
\>[3]{}\hsindent{6}{}\<[9]%
\>[9]{}(\Varid{m-succ}\;\mathbin{:}\;(\Varid{n}\;\mathbin{:}\;\Conid{Nat})\;\to \;\Conid{P}\;\Varid{n}\;\to \;\Conid{P}\;(\Varid{succ}\;\Varid{n}))\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\to \;{}\<[9]%
\>[9]{}(\Varid{n}\;\mathbin{:}\;\Conid{Nat})\;\to \;\Conid{P}\;\Varid{n}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

In order to show that the predicate \ensuremath{\Conid{P}} holds for every \ensuremath{\Varid{n}\;\mathbin{:}\;\Conid{Nat}}, we
have to give a method for every constructor, which shows that \ensuremath{\Conid{P}}
holds for that constructor, given that it holds for all its subterms.

Generalising this to an inductive type \ensuremath{\Conid{T}}, given by a container \ensuremath{\Conid{F}\;\mathbin{:}\;\Conid{Type}\;\to \;\Conid{Type}} and constructor \ensuremath{\Varid{c}\;\mathbin{:}\;\Conid{F}\;\Conid{T}\;\to \;\Conid{T}}, we get:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{ind}\;\mathbin{:}\;{}\<[E]%
\\
\>[3]{}\hsindent{6}{}\<[9]%
\>[9]{}(\Conid{P}\;\mathbin{:}\;\Conid{T}\;\to \;\Conid{Type})\;{}\<[E]%
\\
\>[3]{}\hsindent{6}{}\<[9]%
\>[9]{}(\Varid{m}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F}\;\Conid{T})\;\to \;\Varid{□}\;\Conid{F}\;\Conid{B}\;\Varid{x}\;\to \;\Conid{B}\;(\Varid{c}\;\Varid{x}))\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\to \;{}\<[9]%
\>[9]{}(\Varid{x}\;\mathbin{:}\;\Conid{T})\;\to \;\Conid{P}\;\Varid{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

with computation rule:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{ind-β}\;\mathbin{:}\;{}\<[E]%
\\
\>[3]{}\hsindent{6}{}\<[9]%
\>[9]{}(\Conid{P}\;\mathbin{:}\;\Conid{T}\;\to \;\Conid{Type})\;{}\<[E]%
\\
\>[3]{}\hsindent{6}{}\<[9]%
\>[9]{}(\Varid{m}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F}\;\Conid{T})\;\to \;\Varid{□}\;\Conid{F}\;\Conid{B}\;\Varid{x}\;\to \;\Conid{B}\;(\Varid{c}\;\Varid{x}))\;{}\<[E]%
\\
\>[3]{}\hsindent{6}{}\<[9]%
\>[9]{}(\Varid{x}\;\mathbin{:}\;\Conid{F}\;\Conid{T})\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\to \;{}\<[9]%
\>[9]{}\Varid{ind}\;\Conid{P}\;\Varid{m}\;(\Varid{c}\;\Varid{x})\;=\;\Varid{m}\;\Varid{x}\;(\Varid{□-lift}\;\Conid{F}\;\Conid{B}\;(\Varid{ind}\;\Conid{P}\;\Varid{m})\;\Varid{x}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The modality \ensuremath{\Varid{□}} lifts the predicate \ensuremath{\Conid{P}} on \ensuremath{\Conid{T}} to a predicate on \ensuremath{\Conid{F}\;\Conid{T}}:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{□}\;\Conid{F}\;\Conid{P}\;\mathbin{:}\;\Conid{F}\;\Conid{T}\;\to \;\Conid{Type}{}\<[E]%
\\
\>[3]{}\Varid{□}\;\Conid{F}\;\Conid{P}\;(\Varid{s},\Varid{t})\;:\equiv\;(\Varid{p}\;\mathbin{:}\;\Conid{Pos}\;\Varid{s})\;\to \;\Conid{B}\;(\Varid{t}\;\Varid{p}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

where \ensuremath{\Conid{Pos}} is the position type of the container \ensuremath{\Conid{F}}. The type \ensuremath{\Varid{□}\;\Conid{F}\;\Conid{B}\;\Varid{x}} can be interpreted as: the predicate \ensuremath{\Conid{P}} holds for all of the
subterms of \ensuremath{\Varid{c}\;\Varid{x}\;\mathbin{:}\;\Conid{T}}. \ensuremath{\Varid{□-lift}} lifts dependent functions:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{□-lift}\;\mathbin{:}\;((\Varid{x}\;\mathbin{:}\;\Conid{A})\;\to \;\Conid{B}\;\Varid{x})\;\to \;(\Varid{x}\;\mathbin{:}\;\Conid{F}\;\Conid{A})\;\to \;\Varid{□}\;\Conid{F}\;\Conid{B}\;\Varid{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The induction principle gives us a dependent function \ensuremath{(\Varid{x}\;\mathbin{:}\;\Conid{T})\;\to \;\Conid{P}\;\Varid{t}}
for a family \ensuremath{\Conid{P}\;\mathbin{:}\;\Conid{T}\;\to \;\Conid{Type}}. Equivalently, we can ask for a section
\ensuremath{\Varid{σ}\;\mathbin{:}\;\Conid{B}\;\to \;\Conid{T}} of a function \ensuremath{\Varid{p}\;\mathbin{:}\;\Conid{T}\;\to \;\Conid{B}} for some \ensuremath{\Conid{B}\;\mathbin{:}\;\Conid{Type}}. For any
algebra \ensuremath{(\Conid{B},\Varid{θ})}, initiality gives us an algebra morphism \ensuremath{\Varid{σ}\;\mathbin{:}\;(\Conid{T},\Varid{c})\;\to \;(\Conid{B},\Varid{θ})}. We can ask ourselves what extra conditions we need to
impose on the algebra \ensuremath{(\Conid{B},\Varid{θ})} in order for \ensuremath{\Varid{σ}} to be a section of
\ensuremath{\Varid{p}}. If \ensuremath{\Varid{p}} turns out to be an algebra morphism \ensuremath{(\Conid{B},\Varid{θ})\;\to \;(\Conid{T},\Varid{c})},
then the following diagram commutes:

\begin{center}
  \begin{tikzpicture}[description/.style={fill=white,inner sep=2pt}]
    \matrix (m) [matrix of math nodes, 
                row sep=4.5em,
                column sep=3.5em,
                text height=1.5ex,
                text depth=0.25ex]
 { \ensuremath{\Conid{FT}} & & \ensuremath{\Conid{T}} \\
   \ensuremath{\Conid{FB}} & & \ensuremath{\Conid{B}} \\ 
   \ensuremath{\Conid{FT}} & & \ensuremath{\Conid{T}} \\ };

  \path[->] (m-1-1) edge[decorate] node[auto]       {\ensuremath{\Varid{c}}}  (m-1-3);
  \path[->] (m-1-3) edge[decorate] node[auto]       {\ensuremath{\Varid{σ}}}  (m-2-3);
  \path[->] (m-1-1) edge[decorate] node[auto,swap]  {\ensuremath{\Conid{Fσ}}} (m-2-1);
  \path[->] (m-2-1) edge[decorate] node[auto]       {\ensuremath{\Varid{θ}}}  (m-2-3);
  \path[->] (m-2-3) edge[decorate] node[auto]       {\ensuremath{\Varid{p}}}  (m-3-3);
  \path[->] (m-2-1) edge[decorate] node[auto,swap]  {\ensuremath{\Conid{Fp}}} (m-3-1);
  \path[->] (m-3-1) edge[decorate] node[auto]       {\ensuremath{\Varid{c}}}  (m-3-3);
  \end{tikzpicture}
\end{center}

\ensuremath{\Varid{p}\;\Varid{∘}\;\Varid{σ}} is an algebra morphism \ensuremath{(\Conid{T},\Varid{c})\;\to \;(\Conid{T},\Varid{c})}. Since \ensuremath{\Varid{id}} is also
an algebra morphism \ensuremath{(\Conid{T},\Varid{c})\;\to \;(\Conid{T},\Varid{c})}, by uniqueness we can conclude
that \ensuremath{\Varid{p}\;\Varid{∘}\;\Varid{σ}\;=\;\Varid{id}}, so \ensuremath{\Varid{σ}} is indeed a section.

By choosing \ensuremath{\Conid{B}\;:\equiv\;\Conid{Σ}\;\Conid{T}\;\Conid{P}} and \ensuremath{\Varid{p}\;:\equiv\;\Varid{π₀}}, we can derive the induction
principle mentioned above, observing that \ensuremath{\Conid{F}\;(\Conid{Σ}\;\Conid{T}\;\Conid{P})\;\Varid{≃}\;\Conid{Σ}\;(\Conid{FT})\;(\Varid{□}\;\Conid{F}\;\Conid{P})}.

\subsection{Induction principle for \ronehits}

An induction principle for \ronehits can be derived using the method
mentioned previously: the data for induction should be an algebra
structure on \ensuremath{\Conid{Σ}\;\Conid{T}\;\Conid{P}} such that \ensuremath{\Varid{π₀}} is an algebra morphism \ensuremath{(\Conid{Σ}\;\Conid{T}\;\Conid{P},\Varid{π₀},\Conid{G}\;\Varid{π₀})\;\to \;(\Conid{T},\Varid{c₀},\Varid{c₁})}. We have to produce the methods:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{m₀}\;\mathbin{:}\;\Conid{F₀}\;(\Conid{Σ}\;\Conid{T}\;\Conid{P})\;\to \;\Conid{Σ}\;\Conid{T}\;\Conid{P}{}\<[E]%
\\
\>[3]{}\Varid{m₁}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F₁}\;(\Conid{Σ}\;\Conid{T}\;\Conid{P}))\;\to \;\Conid{G}\;(\Conid{Σ}\;\Conid{T}\;\Conid{P},\Varid{m₀})\;\Varid{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

subject to the equations:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{m-β₀}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F₀}\;(\Conid{Σ}\;\Conid{T}\;\Conid{P}))\;\to \;\Varid{π₀}\;(\Varid{m₀}\;\Varid{x})\;=\;\Varid{c₀}\;(\Conid{F₀}\;\Varid{π₀}\;\Varid{x}){}\<[E]%
\\
\>[3]{}\Varid{m-β₁}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F₁}\;(\Conid{Σ}\;\Conid{T}\;\Conid{P}))\;\to \;\Conid{G}\;(\Varid{π₀},\Varid{m-β₀})\;(\Varid{m₁}\;\Varid{x})\;=\;\Varid{c₁}\;(\Conid{F₁}\;\Varid{π₀}\;\Varid{x}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

From this we can make derive the methods for the induction principle:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{m₀}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F₀}\;\Conid{T})\;\to \;\Varid{□}\;\Conid{F₀}\;\Conid{P}\;\Varid{x}\;\to \;\Conid{P}\;(\Varid{c₀}\;\Varid{x}){}\<[E]%
\\
\>[3]{}\Varid{m₁}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F₁}\;\Conid{T})\;(\Varid{y}\;\mathbin{:}\;\Varid{□}\;\Conid{F₁}\;\Conid{P}\;\Varid{x})\;\to \;\Varid{m₀}\;\Varid{*ᵈ}\;(\Varid{lᵈ}\;\Varid{x}\;\Varid{y})\;=\;\Varid{m₀}\;\Varid{*ᵈ}\;(\Varid{rᵈ}\;\Varid{x}\;\Varid{y})\;[\mskip1.5mu \Conid{P}\;\Varid{↓}\;\Varid{c₁}\;\Varid{x}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

where:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{lᵈ},\Varid{rᵈ}\;{}\<[11]%
\>[11]{}\mathbin{:}\;\{\mskip1.5mu \Conid{A}\;\mathbin{:}\;\Conid{Type0}\mskip1.5mu\}\;\{\mskip1.5mu \Conid{B}\;\mathbin{:}\;\Conid{A}\;\to \;\Conid{Type0}\mskip1.5mu\}\;{}\<[E]%
\\
\>[11]{}\to \;(\Varid{x}\;\mathbin{:}\;\Conid{F₁}\;\Conid{A})\;\to \;\Varid{□}\;\Conid{F₁}\;\Conid{B}\;\Varid{x}\;\to \;\Conid{Σ}\;(\Conid{F₀}\;\Varid{*})\;(\Varid{□}\;(\Conid{F₀}\;\Varid{*})\;\Conid{B}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

and

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{m₀}\;\Varid{*ᵈ}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{Σ}\;(\Conid{F₀}\;\Varid{*}))\;\Varid{×}\;\Varid{□}\;(\Conid{F₀}\;\Varid{*})\;\Conid{P}\;\Varid{x}\;\to \;\Conid{P}\;(\Varid{c₀}\;(\Varid{π₀}\;\Varid{x})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

are the liftings of their non-dependent counterparts.

\section{Induction implies homotopy initiality}

We want to show that, given \ensuremath{\Conid{T}\;\mathbin{:}\;\Conid{Type}} and \ensuremath{\Varid{c}\;\mathbin{:}\;\Conid{F}\;\Conid{T}\;\to \;\Conid{T}} that
satisfies the induction principle, the algebra \ensuremath{(\Conid{T},\Varid{c})} is initial,
\ie for any algebra \ensuremath{(\Conid{X},\Varid{θ})}, \ensuremath{\Conid{Alg-hom}\;(\Conid{T},\Varid{c})\;(\Conid{X},\Varid{θ})\;\Varid{≃}\;\Varid{1}}. We will
first show that we have an algebra morphism \ensuremath{\Varid{f}\;\mathbin{:}\;(\Conid{T},\Varid{c})\;\to \;(\Conid{X},\Varid{θ})}
and will then show that this algebra morphism is unique.

\subsection{W-types}

\subsubsection{Existence}

We can use the induction principle to produce the algebra morphism we want:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{f}\;\mathbin{:}\;\Conid{T}\;\to \;\Conid{X}{}\<[E]%
\\
\>[3]{}\Varid{f}\;:\equiv\;\Varid{ind}\;(\Varid{λ}\;\Varid{x}\;.\;\Conid{X})\;(\Varid{λ}\;(\Varid{s},\mathunderscore)\;\Varid{t}\;.\;\Varid{θ}\;(\Varid{s},\Varid{t})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The computation rule is then given directly by the computation rule
for the induction rule:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{f₀}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F}\;\Conid{T})\;\to \;\Varid{f}\;(\Varid{θ}\;\Varid{x})\;=\;\Varid{θ}\;(\Conid{F}\;\Varid{f}\;\Varid{x}){}\<[E]%
\\
\>[3]{}\Varid{f₀}\;:\equiv\;\Varid{ind-β}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsubsection{Uniqueness}

Assuming that we have an algebra morphism \ensuremath{(\Varid{g},\Varid{g₀})\;\mathbin{:}\;(\Conid{T},\Varid{c})\;\to \;(\Conid{X},\Varid{θ})}, we need to show that \ensuremath{(\Varid{f},\Varid{f₀})\;=\;(\Varid{g},\Varid{g₀})}. Showing that the \ensuremath{\Varid{f}\;=\;\Varid{g}} can be done by induction, using the motive \ensuremath{\Varid{λ}\;\Varid{x}\;.\;\Varid{f}\;\Varid{x}\;=\;\Varid{g}\;\Varid{x}}. The induction step is then proven as follows:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{step}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Varid{⟦}\;\Conid{F}\;\Varid{⟧₀}\;\Conid{T})\;\Varid{→}\;\Varid{□}\;\Conid{F}\;(\Varid{λ}\;\Varid{x}\;.\;\Varid{f}\;\Varid{x}\;=\;\Varid{g}\;\Varid{x})\;\Varid{x}\;\Varid{→}\;\Varid{f=g-B}\;(\Varid{c}\;\Varid{x}){}\<[E]%
\\
\>[3]{}\Varid{step}\;\Varid{x}\;\Varid{u}\;:\equiv\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{f}\;(\Varid{c}\;\Varid{x})\;{}\<[E]%
\\
\>[5]{}\hsindent{1}{}\<[6]%
\>[6]{}\Varid{=⟪}\;\Varid{f₀}\;\Varid{x}\;\Varid{⟫}\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{θ}\;(\Varid{⟦}\;\Conid{F}\;\Varid{⟧₁}\;\Varid{f}\;\Varid{x})\;{}\<[E]%
\\
\>[5]{}\hsindent{1}{}\<[6]%
\>[6]{}\Varid{=⟪}\;\Varid{ap}\;\Varid{θ}\;(\Varid{ind-hyp}\;\Varid{x}\;\Varid{u})\;\Varid{⟫}\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{θ}\;(\Varid{⟦}\;\Conid{F}\;\Varid{⟧₁}\;\Varid{g}\;\Varid{x})\;{}\<[E]%
\\
\>[5]{}\hsindent{1}{}\<[6]%
\>[6]{}\Varid{=⟪}\;\mathbin{!}\;(\Varid{g₀}\;\Varid{x})\;\Varid{⟫}\;{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{g}\;(\Varid{c}\;\Varid{x})\;\Varid{∎}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

where \ensuremath{\Varid{ind-hyp}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{F}\;\Conid{T})\;\Varid{→}\;\Varid{□}\;\Conid{F}\;(\Varid{λ}\;\Varid{x}\;.\;\Varid{f}\;\Varid{x}\;=\;\Varid{g}\;\Varid{x})\;\Varid{x}\;\Varid{→}\;\Conid{F}\;\Varid{f}\;\Varid{x}\;=\;\Conid{F}\;\Varid{g}\;\Varid{x}}. We can define the witness of \ensuremath{\Varid{f}\;=\;\Varid{g}} as follows:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{p}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{T})\;\to \;\Varid{f}\;\Varid{x}\;=\;\Varid{g}\;\Varid{x}{}\<[E]%
\\
\>[3]{}\Varid{p}\;:\equiv\;\Varid{ind}\;(\Varid{λ}\;\Varid{x}\;.\;\Varid{f}\;\Varid{x}\;=\;\Varid{g}\;\Varid{x})\;\Varid{step}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

which comes with the computation rule:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{p-β₀}\;\mathbin{:}\;(\Varid{x}\;\mathbin{:}\;\Conid{FT})\;\to \;\Varid{p}\;(\Varid{c}\;\Varid{x})\;=\;\Varid{f-β₀}\;\Varid{x}\;\Varid{∙}\;\Varid{ap}\;\Varid{θ}\;(\Varid{ind-hyp}\;\Varid{x}\;(\Varid{□-lift}\;\Conid{F}\;\Varid{p}\;\Varid{x}))\;\Varid{∙}\;\mathbin{!}\;(\Varid{g-β₀}\;\Varid{x}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We now need to show that our witness \ensuremath{\Varid{p}} satisfies the ``computation
rule'' \ensuremath{(\Varid{x}\;\mathbin{:}\;\Conid{FT})\;\to \;\Varid{f-β₀}\;\Varid{x}\;\Varid{∙}\;\Varid{ap}\;(\Varid{λ}\;\Varid{h}\;.\;\Varid{ρ}\;(\Conid{F}\;\Varid{h}\;\Varid{x}))\;\Varid{p}\;=\;\Varid{ap}\;(\Varid{λ}\;\Varid{h}\;.\;\Varid{h}\;(\Varid{θ}\;\Varid{x}))\;\Varid{p}\;\Varid{∙}\;\Varid{g-β₀}\;\Varid{x}}. Let \ensuremath{\Varid{x}\;\mathbin{:}\;\Conid{FT}}, then we can calculate:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\Varid{f-β₀}\;\Varid{x}\;\Varid{∙}\;\Varid{ap}\;(\Varid{λ}\;\Varid{h}\;.\;\Varid{θ}\;(\Conid{F}\;\Varid{h}\;\Varid{x}))\;(\Varid{fun-ext}\;\Varid{p})\;{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\hsindent{1}{}\<[4]%
\>[4]{}=\;\{\mskip1.5mu \Varid{ap}\;\Varid{magic}\mskip1.5mu\}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\Varid{f-β₀}\;\Varid{x}\;\Varid{∙}\;\Varid{ap}\;\Varid{θ}\;(\Varid{ind-hyp}\;\Varid{x}\;(\Varid{□-lift}\;\Conid{F}\;\Varid{p}\;\Varid{x}))\;{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\hsindent{1}{}\<[4]%
\>[4]{}=\;\{\mskip1.5mu \Varid{symmetry}\;\Varid{is}\;\Varid{involutive}\mskip1.5mu\}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\Varid{f-β₀}\;\Varid{x}\;\Varid{∙}\;\Varid{ap}\;\Varid{θ}\;(\Varid{ind-hyp}\;\Varid{x}\;(\Varid{□-lift}\;\Conid{F}\;\Varid{p}\;\Varid{x}))\;\Varid{∙}\;\mathbin{!}\;(\Varid{g-β₀}\;\Varid{x})\;\Varid{∙}\;\Varid{g-β₀}\;\Varid{x}\;{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\hsindent{1}{}\<[4]%
\>[4]{}=\;\{\mskip1.5mu \Varid{computation}\;\Varid{rule}\;\Varid{for}\;\Varid{p}\mskip1.5mu\}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\Varid{p}\;(\Varid{c}\;\Varid{x})\;\Varid{∙}\;\Varid{g-β₀}\;\Varid{x}\;{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\hsindent{1}{}\<[4]%
\>[4]{}=\;\{\mskip1.5mu \Varid{computation}\;\Varid{rule}\;\Varid{for}\;\Varid{fun-ext}\mskip1.5mu\}{}\<[E]%
\\[\blanklineskip]%
\>[3]{}\Varid{ap}\;(\Varid{λ}\;\Varid{h}\;.\;\Varid{h}\;(\Varid{c}\;\Varid{x}))\;(\Varid{fun-ext}\;\Varid{p})\;\Varid{∙}\;\Varid{g-β₀}\;\Varid{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We have now established initiality of \ensuremath{(\Conid{T},\Varid{c})}.

\subsection{\Ronehits}

\subsubsection{Existence}

\subsubsection{Uniqueness}

\end{document}
